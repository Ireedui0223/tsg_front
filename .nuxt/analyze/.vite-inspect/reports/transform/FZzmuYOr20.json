{
  "resolvedId": "C:/Users/Ireedui/Desktop/additional/tsg/front-latest/node_modules/vue-sweetalert2/dist/vue-sweetalert.es.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "var commonjsGlobal = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nvar sweetalert2 = { exports: {} };\n/*!\n* sweetalert2 v11.4.0\n* Released under the MIT License.\n*/\n(function(module, exports) {\n  (function(global2, factory) {\n    module.exports = factory();\n  })(commonjsGlobal, function() {\n    const consolePrefix = \"SweetAlert2:\";\n    const uniqueArray = (arr) => {\n      const result = [];\n      for (let i = 0; i < arr.length; i++) {\n        if (result.indexOf(arr[i]) === -1) {\n          result.push(arr[i]);\n        }\n      }\n      return result;\n    };\n    const capitalizeFirstLetter = (str) => str.charAt(0).toUpperCase() + str.slice(1);\n    const toArray = (nodeList) => Array.prototype.slice.call(nodeList);\n    const warn = (message) => {\n      console.warn(\"\".concat(consolePrefix, \" \").concat(typeof message === \"object\" ? message.join(\" \") : message));\n    };\n    const error = (message) => {\n      console.error(\"\".concat(consolePrefix, \" \").concat(message));\n    };\n    const previousWarnOnceMessages = [];\n    const warnOnce = (message) => {\n      if (!previousWarnOnceMessages.includes(message)) {\n        previousWarnOnceMessages.push(message);\n        warn(message);\n      }\n    };\n    const warnAboutDeprecation = (deprecatedParam, useInstead) => {\n      warnOnce('\"'.concat(deprecatedParam, '\" is deprecated and will be removed in the next major release. Please use \"').concat(useInstead, '\" instead.'));\n    };\n    const callIfFunction = (arg) => typeof arg === \"function\" ? arg() : arg;\n    const hasToPromiseFn = (arg) => arg && typeof arg.toPromise === \"function\";\n    const asPromise = (arg) => hasToPromiseFn(arg) ? arg.toPromise() : Promise.resolve(arg);\n    const isPromise = (arg) => arg && Promise.resolve(arg) === arg;\n    const defaultParams = {\n      title: \"\",\n      titleText: \"\",\n      text: \"\",\n      html: \"\",\n      footer: \"\",\n      icon: void 0,\n      iconColor: void 0,\n      iconHtml: void 0,\n      template: void 0,\n      toast: false,\n      showClass: {\n        popup: \"swal2-show\",\n        backdrop: \"swal2-backdrop-show\",\n        icon: \"swal2-icon-show\"\n      },\n      hideClass: {\n        popup: \"swal2-hide\",\n        backdrop: \"swal2-backdrop-hide\",\n        icon: \"swal2-icon-hide\"\n      },\n      customClass: {},\n      target: \"body\",\n      color: void 0,\n      backdrop: true,\n      heightAuto: true,\n      allowOutsideClick: true,\n      allowEscapeKey: true,\n      allowEnterKey: true,\n      stopKeydownPropagation: true,\n      keydownListenerCapture: false,\n      showConfirmButton: true,\n      showDenyButton: false,\n      showCancelButton: false,\n      preConfirm: void 0,\n      preDeny: void 0,\n      confirmButtonText: \"OK\",\n      confirmButtonAriaLabel: \"\",\n      confirmButtonColor: void 0,\n      denyButtonText: \"No\",\n      denyButtonAriaLabel: \"\",\n      denyButtonColor: void 0,\n      cancelButtonText: \"Cancel\",\n      cancelButtonAriaLabel: \"\",\n      cancelButtonColor: void 0,\n      buttonsStyling: true,\n      reverseButtons: false,\n      focusConfirm: true,\n      focusDeny: false,\n      focusCancel: false,\n      returnFocus: true,\n      showCloseButton: false,\n      closeButtonHtml: \"&times;\",\n      closeButtonAriaLabel: \"Close this dialog\",\n      loaderHtml: \"\",\n      showLoaderOnConfirm: false,\n      showLoaderOnDeny: false,\n      imageUrl: void 0,\n      imageWidth: void 0,\n      imageHeight: void 0,\n      imageAlt: \"\",\n      timer: void 0,\n      timerProgressBar: false,\n      width: void 0,\n      padding: void 0,\n      background: void 0,\n      input: void 0,\n      inputPlaceholder: \"\",\n      inputLabel: \"\",\n      inputValue: \"\",\n      inputOptions: {},\n      inputAutoTrim: true,\n      inputAttributes: {},\n      inputValidator: void 0,\n      returnInputValueOnDeny: false,\n      validationMessage: void 0,\n      grow: false,\n      position: \"center\",\n      progressSteps: [],\n      currentProgressStep: void 0,\n      progressStepsDistance: void 0,\n      willOpen: void 0,\n      didOpen: void 0,\n      didRender: void 0,\n      willClose: void 0,\n      didClose: void 0,\n      didDestroy: void 0,\n      scrollbarPadding: true\n    };\n    const updatableParams = [\"allowEscapeKey\", \"allowOutsideClick\", \"background\", \"buttonsStyling\", \"cancelButtonAriaLabel\", \"cancelButtonColor\", \"cancelButtonText\", \"closeButtonAriaLabel\", \"closeButtonHtml\", \"color\", \"confirmButtonAriaLabel\", \"confirmButtonColor\", \"confirmButtonText\", \"currentProgressStep\", \"customClass\", \"denyButtonAriaLabel\", \"denyButtonColor\", \"denyButtonText\", \"didClose\", \"didDestroy\", \"footer\", \"hideClass\", \"html\", \"icon\", \"iconColor\", \"iconHtml\", \"imageAlt\", \"imageHeight\", \"imageUrl\", \"imageWidth\", \"preConfirm\", \"preDeny\", \"progressSteps\", \"returnFocus\", \"reverseButtons\", \"showCancelButton\", \"showCloseButton\", \"showConfirmButton\", \"showDenyButton\", \"text\", \"title\", \"titleText\", \"willClose\"];\n    const deprecatedParams = {};\n    const toastIncompatibleParams = [\"allowOutsideClick\", \"allowEnterKey\", \"backdrop\", \"focusConfirm\", \"focusDeny\", \"focusCancel\", \"returnFocus\", \"heightAuto\", \"keydownListenerCapture\"];\n    const isValidParameter = (paramName) => {\n      return Object.prototype.hasOwnProperty.call(defaultParams, paramName);\n    };\n    const isUpdatableParameter = (paramName) => {\n      return updatableParams.indexOf(paramName) !== -1;\n    };\n    const isDeprecatedParameter = (paramName) => {\n      return deprecatedParams[paramName];\n    };\n    const checkIfParamIsValid = (param) => {\n      if (!isValidParameter(param)) {\n        warn('Unknown parameter \"'.concat(param, '\"'));\n      }\n    };\n    const checkIfToastParamIsValid = (param) => {\n      if (toastIncompatibleParams.includes(param)) {\n        warn('The parameter \"'.concat(param, '\" is incompatible with toasts'));\n      }\n    };\n    const checkIfParamIsDeprecated = (param) => {\n      if (isDeprecatedParameter(param)) {\n        warnAboutDeprecation(param, isDeprecatedParameter(param));\n      }\n    };\n    const showWarningsForParams = (params) => {\n      if (!params.backdrop && params.allowOutsideClick) {\n        warn('\"allowOutsideClick\" parameter requires `backdrop` parameter to be set to `true`');\n      }\n      for (const param in params) {\n        checkIfParamIsValid(param);\n        if (params.toast) {\n          checkIfToastParamIsValid(param);\n        }\n        checkIfParamIsDeprecated(param);\n      }\n    };\n    const swalPrefix = \"swal2-\";\n    const prefix = (items) => {\n      const result = {};\n      for (const i in items) {\n        result[items[i]] = swalPrefix + items[i];\n      }\n      return result;\n    };\n    const swalClasses = prefix([\"container\", \"shown\", \"height-auto\", \"iosfix\", \"popup\", \"modal\", \"no-backdrop\", \"no-transition\", \"toast\", \"toast-shown\", \"show\", \"hide\", \"close\", \"title\", \"html-container\", \"actions\", \"confirm\", \"deny\", \"cancel\", \"default-outline\", \"footer\", \"icon\", \"icon-content\", \"image\", \"input\", \"file\", \"range\", \"select\", \"radio\", \"checkbox\", \"label\", \"textarea\", \"inputerror\", \"input-label\", \"validation-message\", \"progress-steps\", \"active-progress-step\", \"progress-step\", \"progress-step-line\", \"loader\", \"loading\", \"styled\", \"top\", \"top-start\", \"top-end\", \"top-left\", \"top-right\", \"center\", \"center-start\", \"center-end\", \"center-left\", \"center-right\", \"bottom\", \"bottom-start\", \"bottom-end\", \"bottom-left\", \"bottom-right\", \"grow-row\", \"grow-column\", \"grow-fullscreen\", \"rtl\", \"timer-progress-bar\", \"timer-progress-bar-container\", \"scrollbar-measure\", \"icon-success\", \"icon-warning\", \"icon-info\", \"icon-question\", \"icon-error\"]);\n    const iconTypes = prefix([\"success\", \"warning\", \"info\", \"question\", \"error\"]);\n    const getContainer = () => document.body.querySelector(\".\".concat(swalClasses.container));\n    const elementBySelector = (selectorString) => {\n      const container = getContainer();\n      return container ? container.querySelector(selectorString) : null;\n    };\n    const elementByClass = (className) => {\n      return elementBySelector(\".\".concat(className));\n    };\n    const getPopup = () => elementByClass(swalClasses.popup);\n    const getIcon = () => elementByClass(swalClasses.icon);\n    const getTitle = () => elementByClass(swalClasses.title);\n    const getHtmlContainer = () => elementByClass(swalClasses[\"html-container\"]);\n    const getImage = () => elementByClass(swalClasses.image);\n    const getProgressSteps = () => elementByClass(swalClasses[\"progress-steps\"]);\n    const getValidationMessage = () => elementByClass(swalClasses[\"validation-message\"]);\n    const getConfirmButton = () => elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.confirm));\n    const getDenyButton = () => elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.deny));\n    const getInputLabel = () => elementByClass(swalClasses[\"input-label\"]);\n    const getLoader = () => elementBySelector(\".\".concat(swalClasses.loader));\n    const getCancelButton = () => elementBySelector(\".\".concat(swalClasses.actions, \" .\").concat(swalClasses.cancel));\n    const getActions = () => elementByClass(swalClasses.actions);\n    const getFooter = () => elementByClass(swalClasses.footer);\n    const getTimerProgressBar = () => elementByClass(swalClasses[\"timer-progress-bar\"]);\n    const getCloseButton = () => elementByClass(swalClasses.close);\n    const focusable = '\\n  a[href],\\n  area[href],\\n  input:not([disabled]),\\n  select:not([disabled]),\\n  textarea:not([disabled]),\\n  button:not([disabled]),\\n  iframe,\\n  object,\\n  embed,\\n  [tabindex=\"0\"],\\n  [contenteditable],\\n  audio[controls],\\n  video[controls],\\n  summary\\n';\n    const getFocusableElements = () => {\n      const focusableElementsWithTabindex = toArray(getPopup().querySelectorAll('[tabindex]:not([tabindex=\"-1\"]):not([tabindex=\"0\"])')).sort((a, b) => {\n        const tabindexA = parseInt(a.getAttribute(\"tabindex\"));\n        const tabindexB = parseInt(b.getAttribute(\"tabindex\"));\n        if (tabindexA > tabindexB) {\n          return 1;\n        } else if (tabindexA < tabindexB) {\n          return -1;\n        }\n        return 0;\n      });\n      const otherFocusableElements = toArray(getPopup().querySelectorAll(focusable)).filter((el) => el.getAttribute(\"tabindex\") !== \"-1\");\n      return uniqueArray(focusableElementsWithTabindex.concat(otherFocusableElements)).filter((el) => isVisible(el));\n    };\n    const isModal = () => {\n      return !hasClass(document.body, swalClasses[\"toast-shown\"]) && !hasClass(document.body, swalClasses[\"no-backdrop\"]);\n    };\n    const isToast = () => {\n      return getPopup() && hasClass(getPopup(), swalClasses.toast);\n    };\n    const isLoading = () => {\n      return getPopup().hasAttribute(\"data-loading\");\n    };\n    const states = {\n      previousBodyPadding: null\n    };\n    const setInnerHtml = (elem, html) => {\n      elem.textContent = \"\";\n      if (html) {\n        const parser = new DOMParser();\n        const parsed = parser.parseFromString(html, \"text/html\");\n        toArray(parsed.querySelector(\"head\").childNodes).forEach((child) => {\n          elem.appendChild(child);\n        });\n        toArray(parsed.querySelector(\"body\").childNodes).forEach((child) => {\n          elem.appendChild(child);\n        });\n      }\n    };\n    const hasClass = (elem, className) => {\n      if (!className) {\n        return false;\n      }\n      const classList = className.split(/\\s+/);\n      for (let i = 0; i < classList.length; i++) {\n        if (!elem.classList.contains(classList[i])) {\n          return false;\n        }\n      }\n      return true;\n    };\n    const removeCustomClasses = (elem, params) => {\n      toArray(elem.classList).forEach((className) => {\n        if (!Object.values(swalClasses).includes(className) && !Object.values(iconTypes).includes(className) && !Object.values(params.showClass).includes(className)) {\n          elem.classList.remove(className);\n        }\n      });\n    };\n    const applyCustomClass = (elem, params, className) => {\n      removeCustomClasses(elem, params);\n      if (params.customClass && params.customClass[className]) {\n        if (typeof params.customClass[className] !== \"string\" && !params.customClass[className].forEach) {\n          return warn(\"Invalid type of customClass.\".concat(className, '! Expected string or iterable object, got \"').concat(typeof params.customClass[className], '\"'));\n        }\n        addClass(elem, params.customClass[className]);\n      }\n    };\n    const getInput = (popup, inputType) => {\n      if (!inputType) {\n        return null;\n      }\n      switch (inputType) {\n        case \"select\":\n        case \"textarea\":\n        case \"file\":\n          return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses[inputType]));\n        case \"checkbox\":\n          return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.checkbox, \" input\"));\n        case \"radio\":\n          return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.radio, \" input:checked\")) || popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.radio, \" input:first-child\"));\n        case \"range\":\n          return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.range, \" input\"));\n        default:\n          return popup.querySelector(\".\".concat(swalClasses.popup, \" > .\").concat(swalClasses.input));\n      }\n    };\n    const focusInput = (input) => {\n      input.focus();\n      if (input.type !== \"file\") {\n        const val = input.value;\n        input.value = \"\";\n        input.value = val;\n      }\n    };\n    const toggleClass = (target, classList, condition) => {\n      if (!target || !classList) {\n        return;\n      }\n      if (typeof classList === \"string\") {\n        classList = classList.split(/\\s+/).filter(Boolean);\n      }\n      classList.forEach((className) => {\n        if (Array.isArray(target)) {\n          target.forEach((elem) => {\n            condition ? elem.classList.add(className) : elem.classList.remove(className);\n          });\n        } else {\n          condition ? target.classList.add(className) : target.classList.remove(className);\n        }\n      });\n    };\n    const addClass = (target, classList) => {\n      toggleClass(target, classList, true);\n    };\n    const removeClass = (target, classList) => {\n      toggleClass(target, classList, false);\n    };\n    const getDirectChildByClass = (elem, className) => {\n      const childNodes = toArray(elem.childNodes);\n      for (let i = 0; i < childNodes.length; i++) {\n        if (hasClass(childNodes[i], className)) {\n          return childNodes[i];\n        }\n      }\n    };\n    const applyNumericalStyle = (elem, property, value) => {\n      if (value === \"\".concat(parseInt(value))) {\n        value = parseInt(value);\n      }\n      if (value || parseInt(value) === 0) {\n        elem.style[property] = typeof value === \"number\" ? \"\".concat(value, \"px\") : value;\n      } else {\n        elem.style.removeProperty(property);\n      }\n    };\n    const show = function(elem) {\n      let display = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : \"flex\";\n      elem.style.display = display;\n    };\n    const hide = (elem) => {\n      elem.style.display = \"none\";\n    };\n    const setStyle = (parent, selector, property, value) => {\n      const el = parent.querySelector(selector);\n      if (el) {\n        el.style[property] = value;\n      }\n    };\n    const toggle = (elem, condition, display) => {\n      condition ? show(elem, display) : hide(elem);\n    };\n    const isVisible = (elem) => !!(elem && (elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length));\n    const allButtonsAreHidden = () => !isVisible(getConfirmButton()) && !isVisible(getDenyButton()) && !isVisible(getCancelButton());\n    const isScrollable = (elem) => !!(elem.scrollHeight > elem.clientHeight);\n    const hasCssAnimation = (elem) => {\n      const style = window.getComputedStyle(elem);\n      const animDuration = parseFloat(style.getPropertyValue(\"animation-duration\") || \"0\");\n      const transDuration = parseFloat(style.getPropertyValue(\"transition-duration\") || \"0\");\n      return animDuration > 0 || transDuration > 0;\n    };\n    const animateTimerProgressBar = function(timer) {\n      let reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n      const timerProgressBar = getTimerProgressBar();\n      if (isVisible(timerProgressBar)) {\n        if (reset) {\n          timerProgressBar.style.transition = \"none\";\n          timerProgressBar.style.width = \"100%\";\n        }\n        setTimeout(() => {\n          timerProgressBar.style.transition = \"width \".concat(timer / 1e3, \"s linear\");\n          timerProgressBar.style.width = \"0%\";\n        }, 10);\n      }\n    };\n    const stopTimerProgressBar = () => {\n      const timerProgressBar = getTimerProgressBar();\n      const timerProgressBarWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n      timerProgressBar.style.removeProperty(\"transition\");\n      timerProgressBar.style.width = \"100%\";\n      const timerProgressBarFullWidth = parseInt(window.getComputedStyle(timerProgressBar).width);\n      const timerProgressBarPercent = timerProgressBarWidth / timerProgressBarFullWidth * 100;\n      timerProgressBar.style.removeProperty(\"transition\");\n      timerProgressBar.style.width = \"\".concat(timerProgressBarPercent, \"%\");\n    };\n    const isNodeEnv = () => typeof window === \"undefined\" || typeof document === \"undefined\";\n    const RESTORE_FOCUS_TIMEOUT = 100;\n    const globalState = {};\n    const focusPreviousActiveElement = () => {\n      if (globalState.previousActiveElement && globalState.previousActiveElement.focus) {\n        globalState.previousActiveElement.focus();\n        globalState.previousActiveElement = null;\n      } else if (document.body) {\n        document.body.focus();\n      }\n    };\n    const restoreActiveElement = (returnFocus) => {\n      return new Promise((resolve) => {\n        if (!returnFocus) {\n          return resolve();\n        }\n        const x = window.scrollX;\n        const y = window.scrollY;\n        globalState.restoreFocusTimeout = setTimeout(() => {\n          focusPreviousActiveElement();\n          resolve();\n        }, RESTORE_FOCUS_TIMEOUT);\n        window.scrollTo(x, y);\n      });\n    };\n    const sweetHTML = '\\n <div aria-labelledby=\"'.concat(swalClasses.title, '\" aria-describedby=\"').concat(swalClasses[\"html-container\"], '\" class=\"').concat(swalClasses.popup, '\" tabindex=\"-1\">\\n   <button type=\"button\" class=\"').concat(swalClasses.close, '\"></button>\\n   <ul class=\"').concat(swalClasses[\"progress-steps\"], '\"></ul>\\n   <div class=\"').concat(swalClasses.icon, '\"></div>\\n   <img class=\"').concat(swalClasses.image, '\" />\\n   <h2 class=\"').concat(swalClasses.title, '\" id=\"').concat(swalClasses.title, '\"></h2>\\n   <div class=\"').concat(swalClasses[\"html-container\"], '\" id=\"').concat(swalClasses[\"html-container\"], '\"></div>\\n   <input class=\"').concat(swalClasses.input, '\" />\\n   <input type=\"file\" class=\"').concat(swalClasses.file, '\" />\\n   <div class=\"').concat(swalClasses.range, '\">\\n     <input type=\"range\" />\\n     <output></output>\\n   </div>\\n   <select class=\"').concat(swalClasses.select, '\"></select>\\n   <div class=\"').concat(swalClasses.radio, '\"></div>\\n   <label for=\"').concat(swalClasses.checkbox, '\" class=\"').concat(swalClasses.checkbox, '\">\\n     <input type=\"checkbox\" />\\n     <span class=\"').concat(swalClasses.label, '\"></span>\\n   </label>\\n   <textarea class=\"').concat(swalClasses.textarea, '\"></textarea>\\n   <div class=\"').concat(swalClasses[\"validation-message\"], '\" id=\"').concat(swalClasses[\"validation-message\"], '\"></div>\\n   <div class=\"').concat(swalClasses.actions, '\">\\n     <div class=\"').concat(swalClasses.loader, '\"></div>\\n     <button type=\"button\" class=\"').concat(swalClasses.confirm, '\"></button>\\n     <button type=\"button\" class=\"').concat(swalClasses.deny, '\"></button>\\n     <button type=\"button\" class=\"').concat(swalClasses.cancel, '\"></button>\\n   </div>\\n   <div class=\"').concat(swalClasses.footer, '\"></div>\\n   <div class=\"').concat(swalClasses[\"timer-progress-bar-container\"], '\">\\n     <div class=\"').concat(swalClasses[\"timer-progress-bar\"], '\"></div>\\n   </div>\\n </div>\\n').replace(/(^|\\n)\\s*/g, \"\");\n    const resetOldContainer = () => {\n      const oldContainer = getContainer();\n      if (!oldContainer) {\n        return false;\n      }\n      oldContainer.remove();\n      removeClass([document.documentElement, document.body], [swalClasses[\"no-backdrop\"], swalClasses[\"toast-shown\"], swalClasses[\"has-column\"]]);\n      return true;\n    };\n    const resetValidationMessage = () => {\n      globalState.currentInstance.resetValidationMessage();\n    };\n    const addInputChangeListeners = () => {\n      const popup = getPopup();\n      const input = getDirectChildByClass(popup, swalClasses.input);\n      const file = getDirectChildByClass(popup, swalClasses.file);\n      const range = popup.querySelector(\".\".concat(swalClasses.range, \" input\"));\n      const rangeOutput = popup.querySelector(\".\".concat(swalClasses.range, \" output\"));\n      const select = getDirectChildByClass(popup, swalClasses.select);\n      const checkbox = popup.querySelector(\".\".concat(swalClasses.checkbox, \" input\"));\n      const textarea = getDirectChildByClass(popup, swalClasses.textarea);\n      input.oninput = resetValidationMessage;\n      file.onchange = resetValidationMessage;\n      select.onchange = resetValidationMessage;\n      checkbox.onchange = resetValidationMessage;\n      textarea.oninput = resetValidationMessage;\n      range.oninput = () => {\n        resetValidationMessage();\n        rangeOutput.value = range.value;\n      };\n      range.onchange = () => {\n        resetValidationMessage();\n        range.nextSibling.value = range.value;\n      };\n    };\n    const getTarget = (target) => typeof target === \"string\" ? document.querySelector(target) : target;\n    const setupAccessibility = (params) => {\n      const popup = getPopup();\n      popup.setAttribute(\"role\", params.toast ? \"alert\" : \"dialog\");\n      popup.setAttribute(\"aria-live\", params.toast ? \"polite\" : \"assertive\");\n      if (!params.toast) {\n        popup.setAttribute(\"aria-modal\", \"true\");\n      }\n    };\n    const setupRTL = (targetElement) => {\n      if (window.getComputedStyle(targetElement).direction === \"rtl\") {\n        addClass(getContainer(), swalClasses.rtl);\n      }\n    };\n    const init = (params) => {\n      const oldContainerExisted = resetOldContainer();\n      if (isNodeEnv()) {\n        error(\"SweetAlert2 requires document to initialize\");\n        return;\n      }\n      const container = document.createElement(\"div\");\n      container.className = swalClasses.container;\n      if (oldContainerExisted) {\n        addClass(container, swalClasses[\"no-transition\"]);\n      }\n      setInnerHtml(container, sweetHTML);\n      const targetElement = getTarget(params.target);\n      targetElement.appendChild(container);\n      setupAccessibility(params);\n      setupRTL(targetElement);\n      addInputChangeListeners();\n    };\n    const parseHtmlToContainer = (param, target) => {\n      if (param instanceof HTMLElement) {\n        target.appendChild(param);\n      } else if (typeof param === \"object\") {\n        handleObject(param, target);\n      } else if (param) {\n        setInnerHtml(target, param);\n      }\n    };\n    const handleObject = (param, target) => {\n      if (param.jquery) {\n        handleJqueryElem(target, param);\n      } else {\n        setInnerHtml(target, param.toString());\n      }\n    };\n    const handleJqueryElem = (target, elem) => {\n      target.textContent = \"\";\n      if (0 in elem) {\n        for (let i = 0; i in elem; i++) {\n          target.appendChild(elem[i].cloneNode(true));\n        }\n      } else {\n        target.appendChild(elem.cloneNode(true));\n      }\n    };\n    const animationEndEvent = (() => {\n      if (isNodeEnv()) {\n        return false;\n      }\n      const testEl = document.createElement(\"div\");\n      const transEndEventNames = {\n        WebkitAnimation: \"webkitAnimationEnd\",\n        animation: \"animationend\"\n      };\n      for (const i in transEndEventNames) {\n        if (Object.prototype.hasOwnProperty.call(transEndEventNames, i) && typeof testEl.style[i] !== \"undefined\") {\n          return transEndEventNames[i];\n        }\n      }\n      return false;\n    })();\n    const measureScrollbar = () => {\n      const scrollDiv = document.createElement(\"div\");\n      scrollDiv.className = swalClasses[\"scrollbar-measure\"];\n      document.body.appendChild(scrollDiv);\n      const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    };\n    const renderActions = (instance, params) => {\n      const actions = getActions();\n      const loader = getLoader();\n      if (!params.showConfirmButton && !params.showDenyButton && !params.showCancelButton) {\n        hide(actions);\n      } else {\n        show(actions);\n      }\n      applyCustomClass(actions, params, \"actions\");\n      renderButtons(actions, loader, params);\n      setInnerHtml(loader, params.loaderHtml);\n      applyCustomClass(loader, params, \"loader\");\n    };\n    function renderButtons(actions, loader, params) {\n      const confirmButton = getConfirmButton();\n      const denyButton = getDenyButton();\n      const cancelButton = getCancelButton();\n      renderButton(confirmButton, \"confirm\", params);\n      renderButton(denyButton, \"deny\", params);\n      renderButton(cancelButton, \"cancel\", params);\n      handleButtonsStyling(confirmButton, denyButton, cancelButton, params);\n      if (params.reverseButtons) {\n        if (params.toast) {\n          actions.insertBefore(cancelButton, confirmButton);\n          actions.insertBefore(denyButton, confirmButton);\n        } else {\n          actions.insertBefore(cancelButton, loader);\n          actions.insertBefore(denyButton, loader);\n          actions.insertBefore(confirmButton, loader);\n        }\n      }\n    }\n    function handleButtonsStyling(confirmButton, denyButton, cancelButton, params) {\n      if (!params.buttonsStyling) {\n        return removeClass([confirmButton, denyButton, cancelButton], swalClasses.styled);\n      }\n      addClass([confirmButton, denyButton, cancelButton], swalClasses.styled);\n      if (params.confirmButtonColor) {\n        confirmButton.style.backgroundColor = params.confirmButtonColor;\n        addClass(confirmButton, swalClasses[\"default-outline\"]);\n      }\n      if (params.denyButtonColor) {\n        denyButton.style.backgroundColor = params.denyButtonColor;\n        addClass(denyButton, swalClasses[\"default-outline\"]);\n      }\n      if (params.cancelButtonColor) {\n        cancelButton.style.backgroundColor = params.cancelButtonColor;\n        addClass(cancelButton, swalClasses[\"default-outline\"]);\n      }\n    }\n    function renderButton(button, buttonType, params) {\n      toggle(button, params[\"show\".concat(capitalizeFirstLetter(buttonType), \"Button\")], \"inline-block\");\n      setInnerHtml(button, params[\"\".concat(buttonType, \"ButtonText\")]);\n      button.setAttribute(\"aria-label\", params[\"\".concat(buttonType, \"ButtonAriaLabel\")]);\n      button.className = swalClasses[buttonType];\n      applyCustomClass(button, params, \"\".concat(buttonType, \"Button\"));\n      addClass(button, params[\"\".concat(buttonType, \"ButtonClass\")]);\n    }\n    function handleBackdropParam(container, backdrop) {\n      if (typeof backdrop === \"string\") {\n        container.style.background = backdrop;\n      } else if (!backdrop) {\n        addClass([document.documentElement, document.body], swalClasses[\"no-backdrop\"]);\n      }\n    }\n    function handlePositionParam(container, position) {\n      if (position in swalClasses) {\n        addClass(container, swalClasses[position]);\n      } else {\n        warn('The \"position\" parameter is not valid, defaulting to \"center\"');\n        addClass(container, swalClasses.center);\n      }\n    }\n    function handleGrowParam(container, grow) {\n      if (grow && typeof grow === \"string\") {\n        const growClass = \"grow-\".concat(grow);\n        if (growClass in swalClasses) {\n          addClass(container, swalClasses[growClass]);\n        }\n      }\n    }\n    const renderContainer = (instance, params) => {\n      const container = getContainer();\n      if (!container) {\n        return;\n      }\n      handleBackdropParam(container, params.backdrop);\n      handlePositionParam(container, params.position);\n      handleGrowParam(container, params.grow);\n      applyCustomClass(container, params, \"container\");\n    };\n    var privateProps = {\n      awaitingPromise: /* @__PURE__ */ new WeakMap(),\n      promise: /* @__PURE__ */ new WeakMap(),\n      innerParams: /* @__PURE__ */ new WeakMap(),\n      domCache: /* @__PURE__ */ new WeakMap()\n    };\n    const inputTypes = [\"input\", \"file\", \"range\", \"select\", \"radio\", \"checkbox\", \"textarea\"];\n    const renderInput = (instance, params) => {\n      const popup = getPopup();\n      const innerParams = privateProps.innerParams.get(instance);\n      const rerender = !innerParams || params.input !== innerParams.input;\n      inputTypes.forEach((inputType) => {\n        const inputClass = swalClasses[inputType];\n        const inputContainer = getDirectChildByClass(popup, inputClass);\n        setAttributes(inputType, params.inputAttributes);\n        inputContainer.className = inputClass;\n        if (rerender) {\n          hide(inputContainer);\n        }\n      });\n      if (params.input) {\n        if (rerender) {\n          showInput(params);\n        }\n        setCustomClass(params);\n      }\n    };\n    const showInput = (params) => {\n      if (!renderInputType[params.input]) {\n        return error('Unexpected type of input! Expected \"text\", \"email\", \"password\", \"number\", \"tel\", \"select\", \"radio\", \"checkbox\", \"textarea\", \"file\" or \"url\", got \"'.concat(params.input, '\"'));\n      }\n      const inputContainer = getInputContainer(params.input);\n      const input = renderInputType[params.input](inputContainer, params);\n      show(input);\n      setTimeout(() => {\n        focusInput(input);\n      });\n    };\n    const removeAttributes = (input) => {\n      for (let i = 0; i < input.attributes.length; i++) {\n        const attrName = input.attributes[i].name;\n        if (![\"type\", \"value\", \"style\"].includes(attrName)) {\n          input.removeAttribute(attrName);\n        }\n      }\n    };\n    const setAttributes = (inputType, inputAttributes) => {\n      const input = getInput(getPopup(), inputType);\n      if (!input) {\n        return;\n      }\n      removeAttributes(input);\n      for (const attr in inputAttributes) {\n        input.setAttribute(attr, inputAttributes[attr]);\n      }\n    };\n    const setCustomClass = (params) => {\n      const inputContainer = getInputContainer(params.input);\n      if (params.customClass) {\n        addClass(inputContainer, params.customClass.input);\n      }\n    };\n    const setInputPlaceholder = (input, params) => {\n      if (!input.placeholder || params.inputPlaceholder) {\n        input.placeholder = params.inputPlaceholder;\n      }\n    };\n    const setInputLabel = (input, prependTo, params) => {\n      if (params.inputLabel) {\n        input.id = swalClasses.input;\n        const label = document.createElement(\"label\");\n        const labelClass = swalClasses[\"input-label\"];\n        label.setAttribute(\"for\", input.id);\n        label.className = labelClass;\n        addClass(label, params.customClass.inputLabel);\n        label.innerText = params.inputLabel;\n        prependTo.insertAdjacentElement(\"beforebegin\", label);\n      }\n    };\n    const getInputContainer = (inputType) => {\n      const inputClass = swalClasses[inputType] ? swalClasses[inputType] : swalClasses.input;\n      return getDirectChildByClass(getPopup(), inputClass);\n    };\n    const renderInputType = {};\n    renderInputType.text = renderInputType.email = renderInputType.password = renderInputType.number = renderInputType.tel = renderInputType.url = (input, params) => {\n      if (typeof params.inputValue === \"string\" || typeof params.inputValue === \"number\") {\n        input.value = params.inputValue;\n      } else if (!isPromise(params.inputValue)) {\n        warn('Unexpected type of inputValue! Expected \"string\", \"number\" or \"Promise\", got \"'.concat(typeof params.inputValue, '\"'));\n      }\n      setInputLabel(input, input, params);\n      setInputPlaceholder(input, params);\n      input.type = params.input;\n      return input;\n    };\n    renderInputType.file = (input, params) => {\n      setInputLabel(input, input, params);\n      setInputPlaceholder(input, params);\n      return input;\n    };\n    renderInputType.range = (range, params) => {\n      const rangeInput = range.querySelector(\"input\");\n      const rangeOutput = range.querySelector(\"output\");\n      rangeInput.value = params.inputValue;\n      rangeInput.type = params.input;\n      rangeOutput.value = params.inputValue;\n      setInputLabel(rangeInput, range, params);\n      return range;\n    };\n    renderInputType.select = (select, params) => {\n      select.textContent = \"\";\n      if (params.inputPlaceholder) {\n        const placeholder = document.createElement(\"option\");\n        setInnerHtml(placeholder, params.inputPlaceholder);\n        placeholder.value = \"\";\n        placeholder.disabled = true;\n        placeholder.selected = true;\n        select.appendChild(placeholder);\n      }\n      setInputLabel(select, select, params);\n      return select;\n    };\n    renderInputType.radio = (radio) => {\n      radio.textContent = \"\";\n      return radio;\n    };\n    renderInputType.checkbox = (checkboxContainer, params) => {\n      const checkbox = getInput(getPopup(), \"checkbox\");\n      checkbox.value = \"1\";\n      checkbox.id = swalClasses.checkbox;\n      checkbox.checked = Boolean(params.inputValue);\n      const label = checkboxContainer.querySelector(\"span\");\n      setInnerHtml(label, params.inputPlaceholder);\n      return checkboxContainer;\n    };\n    renderInputType.textarea = (textarea, params) => {\n      textarea.value = params.inputValue;\n      setInputPlaceholder(textarea, params);\n      setInputLabel(textarea, textarea, params);\n      const getMargin = (el) => parseInt(window.getComputedStyle(el).marginLeft) + parseInt(window.getComputedStyle(el).marginRight);\n      setTimeout(() => {\n        if (\"MutationObserver\" in window) {\n          const initialPopupWidth = parseInt(window.getComputedStyle(getPopup()).width);\n          const textareaResizeHandler = () => {\n            const textareaWidth = textarea.offsetWidth + getMargin(textarea);\n            if (textareaWidth > initialPopupWidth) {\n              getPopup().style.width = \"\".concat(textareaWidth, \"px\");\n            } else {\n              getPopup().style.width = null;\n            }\n          };\n          new MutationObserver(textareaResizeHandler).observe(textarea, {\n            attributes: true,\n            attributeFilter: [\"style\"]\n          });\n        }\n      });\n      return textarea;\n    };\n    const renderContent = (instance, params) => {\n      const htmlContainer = getHtmlContainer();\n      applyCustomClass(htmlContainer, params, \"htmlContainer\");\n      if (params.html) {\n        parseHtmlToContainer(params.html, htmlContainer);\n        show(htmlContainer, \"block\");\n      } else if (params.text) {\n        htmlContainer.textContent = params.text;\n        show(htmlContainer, \"block\");\n      } else {\n        hide(htmlContainer);\n      }\n      renderInput(instance, params);\n    };\n    const renderFooter = (instance, params) => {\n      const footer = getFooter();\n      toggle(footer, params.footer);\n      if (params.footer) {\n        parseHtmlToContainer(params.footer, footer);\n      }\n      applyCustomClass(footer, params, \"footer\");\n    };\n    const renderCloseButton = (instance, params) => {\n      const closeButton = getCloseButton();\n      setInnerHtml(closeButton, params.closeButtonHtml);\n      applyCustomClass(closeButton, params, \"closeButton\");\n      toggle(closeButton, params.showCloseButton);\n      closeButton.setAttribute(\"aria-label\", params.closeButtonAriaLabel);\n    };\n    const renderIcon = (instance, params) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      const icon = getIcon();\n      if (innerParams && params.icon === innerParams.icon) {\n        setContent(icon, params);\n        applyStyles(icon, params);\n        return;\n      }\n      if (!params.icon && !params.iconHtml) {\n        return hide(icon);\n      }\n      if (params.icon && Object.keys(iconTypes).indexOf(params.icon) === -1) {\n        error('Unknown icon! Expected \"success\", \"error\", \"warning\", \"info\" or \"question\", got \"'.concat(params.icon, '\"'));\n        return hide(icon);\n      }\n      show(icon);\n      setContent(icon, params);\n      applyStyles(icon, params);\n      addClass(icon, params.showClass.icon);\n    };\n    const applyStyles = (icon, params) => {\n      for (const iconType in iconTypes) {\n        if (params.icon !== iconType) {\n          removeClass(icon, iconTypes[iconType]);\n        }\n      }\n      addClass(icon, iconTypes[params.icon]);\n      setColor(icon, params);\n      adjustSuccessIconBackgroundColor();\n      applyCustomClass(icon, params, \"icon\");\n    };\n    const adjustSuccessIconBackgroundColor = () => {\n      const popup = getPopup();\n      const popupBackgroundColor = window.getComputedStyle(popup).getPropertyValue(\"background-color\");\n      const successIconParts = popup.querySelectorAll(\"[class^=swal2-success-circular-line], .swal2-success-fix\");\n      for (let i = 0; i < successIconParts.length; i++) {\n        successIconParts[i].style.backgroundColor = popupBackgroundColor;\n      }\n    };\n    const successIconHtml = '\\n  <div class=\"swal2-success-circular-line-left\"></div>\\n  <span class=\"swal2-success-line-tip\"></span> <span class=\"swal2-success-line-long\"></span>\\n  <div class=\"swal2-success-ring\"></div> <div class=\"swal2-success-fix\"></div>\\n  <div class=\"swal2-success-circular-line-right\"></div>\\n';\n    const errorIconHtml = '\\n  <span class=\"swal2-x-mark\">\\n    <span class=\"swal2-x-mark-line-left\"></span>\\n    <span class=\"swal2-x-mark-line-right\"></span>\\n  </span>\\n';\n    const setContent = (icon, params) => {\n      icon.textContent = \"\";\n      if (params.iconHtml) {\n        setInnerHtml(icon, iconContent(params.iconHtml));\n      } else if (params.icon === \"success\") {\n        setInnerHtml(icon, successIconHtml);\n      } else if (params.icon === \"error\") {\n        setInnerHtml(icon, errorIconHtml);\n      } else {\n        const defaultIconHtml = {\n          question: \"?\",\n          warning: \"!\",\n          info: \"i\"\n        };\n        setInnerHtml(icon, iconContent(defaultIconHtml[params.icon]));\n      }\n    };\n    const setColor = (icon, params) => {\n      if (!params.iconColor) {\n        return;\n      }\n      icon.style.color = params.iconColor;\n      icon.style.borderColor = params.iconColor;\n      for (const sel of [\".swal2-success-line-tip\", \".swal2-success-line-long\", \".swal2-x-mark-line-left\", \".swal2-x-mark-line-right\"]) {\n        setStyle(icon, sel, \"backgroundColor\", params.iconColor);\n      }\n      setStyle(icon, \".swal2-success-ring\", \"borderColor\", params.iconColor);\n    };\n    const iconContent = (content) => '<div class=\"'.concat(swalClasses[\"icon-content\"], '\">').concat(content, \"</div>\");\n    const renderImage = (instance, params) => {\n      const image = getImage();\n      if (!params.imageUrl) {\n        return hide(image);\n      }\n      show(image, \"\");\n      image.setAttribute(\"src\", params.imageUrl);\n      image.setAttribute(\"alt\", params.imageAlt);\n      applyNumericalStyle(image, \"width\", params.imageWidth);\n      applyNumericalStyle(image, \"height\", params.imageHeight);\n      image.className = swalClasses.image;\n      applyCustomClass(image, params, \"image\");\n    };\n    const createStepElement = (step) => {\n      const stepEl = document.createElement(\"li\");\n      addClass(stepEl, swalClasses[\"progress-step\"]);\n      setInnerHtml(stepEl, step);\n      return stepEl;\n    };\n    const createLineElement = (params) => {\n      const lineEl = document.createElement(\"li\");\n      addClass(lineEl, swalClasses[\"progress-step-line\"]);\n      if (params.progressStepsDistance) {\n        lineEl.style.width = params.progressStepsDistance;\n      }\n      return lineEl;\n    };\n    const renderProgressSteps = (instance, params) => {\n      const progressStepsContainer = getProgressSteps();\n      if (!params.progressSteps || params.progressSteps.length === 0) {\n        return hide(progressStepsContainer);\n      }\n      show(progressStepsContainer);\n      progressStepsContainer.textContent = \"\";\n      if (params.currentProgressStep >= params.progressSteps.length) {\n        warn(\"Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)\");\n      }\n      params.progressSteps.forEach((step, index) => {\n        const stepEl = createStepElement(step);\n        progressStepsContainer.appendChild(stepEl);\n        if (index === params.currentProgressStep) {\n          addClass(stepEl, swalClasses[\"active-progress-step\"]);\n        }\n        if (index !== params.progressSteps.length - 1) {\n          const lineEl = createLineElement(params);\n          progressStepsContainer.appendChild(lineEl);\n        }\n      });\n    };\n    const renderTitle = (instance, params) => {\n      const title = getTitle();\n      toggle(title, params.title || params.titleText, \"block\");\n      if (params.title) {\n        parseHtmlToContainer(params.title, title);\n      }\n      if (params.titleText) {\n        title.innerText = params.titleText;\n      }\n      applyCustomClass(title, params, \"title\");\n    };\n    const renderPopup = (instance, params) => {\n      const container = getContainer();\n      const popup = getPopup();\n      if (params.toast) {\n        applyNumericalStyle(container, \"width\", params.width);\n        popup.style.width = \"100%\";\n        popup.insertBefore(getLoader(), getIcon());\n      } else {\n        applyNumericalStyle(popup, \"width\", params.width);\n      }\n      applyNumericalStyle(popup, \"padding\", params.padding);\n      if (params.color) {\n        popup.style.color = params.color;\n      }\n      if (params.background) {\n        popup.style.background = params.background;\n      }\n      hide(getValidationMessage());\n      addClasses(popup, params);\n    };\n    const addClasses = (popup, params) => {\n      popup.className = \"\".concat(swalClasses.popup, \" \").concat(isVisible(popup) ? params.showClass.popup : \"\");\n      if (params.toast) {\n        addClass([document.documentElement, document.body], swalClasses[\"toast-shown\"]);\n        addClass(popup, swalClasses.toast);\n      } else {\n        addClass(popup, swalClasses.modal);\n      }\n      applyCustomClass(popup, params, \"popup\");\n      if (typeof params.customClass === \"string\") {\n        addClass(popup, params.customClass);\n      }\n      if (params.icon) {\n        addClass(popup, swalClasses[\"icon-\".concat(params.icon)]);\n      }\n    };\n    const render = (instance, params) => {\n      renderPopup(instance, params);\n      renderContainer(instance, params);\n      renderProgressSteps(instance, params);\n      renderIcon(instance, params);\n      renderImage(instance, params);\n      renderTitle(instance, params);\n      renderCloseButton(instance, params);\n      renderContent(instance, params);\n      renderActions(instance, params);\n      renderFooter(instance, params);\n      if (typeof params.didRender === \"function\") {\n        params.didRender(getPopup());\n      }\n    };\n    const DismissReason = Object.freeze({\n      cancel: \"cancel\",\n      backdrop: \"backdrop\",\n      close: \"close\",\n      esc: \"esc\",\n      timer: \"timer\"\n    });\n    const setAriaHidden = () => {\n      const bodyChildren = toArray(document.body.children);\n      bodyChildren.forEach((el) => {\n        if (el === getContainer() || el.contains(getContainer())) {\n          return;\n        }\n        if (el.hasAttribute(\"aria-hidden\")) {\n          el.setAttribute(\"data-previous-aria-hidden\", el.getAttribute(\"aria-hidden\"));\n        }\n        el.setAttribute(\"aria-hidden\", \"true\");\n      });\n    };\n    const unsetAriaHidden = () => {\n      const bodyChildren = toArray(document.body.children);\n      bodyChildren.forEach((el) => {\n        if (el.hasAttribute(\"data-previous-aria-hidden\")) {\n          el.setAttribute(\"aria-hidden\", el.getAttribute(\"data-previous-aria-hidden\"));\n          el.removeAttribute(\"data-previous-aria-hidden\");\n        } else {\n          el.removeAttribute(\"aria-hidden\");\n        }\n      });\n    };\n    const swalStringParams = [\"swal-title\", \"swal-html\", \"swal-footer\"];\n    const getTemplateParams = (params) => {\n      const template = typeof params.template === \"string\" ? document.querySelector(params.template) : params.template;\n      if (!template) {\n        return {};\n      }\n      const templateContent = template.content;\n      showWarningsForElements(templateContent);\n      const result = Object.assign(getSwalParams(templateContent), getSwalButtons(templateContent), getSwalImage(templateContent), getSwalIcon(templateContent), getSwalInput(templateContent), getSwalStringParams(templateContent, swalStringParams));\n      return result;\n    };\n    const getSwalParams = (templateContent) => {\n      const result = {};\n      toArray(templateContent.querySelectorAll(\"swal-param\")).forEach((param) => {\n        showWarningsForAttributes(param, [\"name\", \"value\"]);\n        const paramName = param.getAttribute(\"name\");\n        const value = param.getAttribute(\"value\");\n        if (typeof defaultParams[paramName] === \"boolean\" && value === \"false\") {\n          result[paramName] = false;\n        }\n        if (typeof defaultParams[paramName] === \"object\") {\n          result[paramName] = JSON.parse(value);\n        }\n      });\n      return result;\n    };\n    const getSwalButtons = (templateContent) => {\n      const result = {};\n      toArray(templateContent.querySelectorAll(\"swal-button\")).forEach((button) => {\n        showWarningsForAttributes(button, [\"type\", \"color\", \"aria-label\"]);\n        const type = button.getAttribute(\"type\");\n        result[\"\".concat(type, \"ButtonText\")] = button.innerHTML;\n        result[\"show\".concat(capitalizeFirstLetter(type), \"Button\")] = true;\n        if (button.hasAttribute(\"color\")) {\n          result[\"\".concat(type, \"ButtonColor\")] = button.getAttribute(\"color\");\n        }\n        if (button.hasAttribute(\"aria-label\")) {\n          result[\"\".concat(type, \"ButtonAriaLabel\")] = button.getAttribute(\"aria-label\");\n        }\n      });\n      return result;\n    };\n    const getSwalImage = (templateContent) => {\n      const result = {};\n      const image = templateContent.querySelector(\"swal-image\");\n      if (image) {\n        showWarningsForAttributes(image, [\"src\", \"width\", \"height\", \"alt\"]);\n        if (image.hasAttribute(\"src\")) {\n          result.imageUrl = image.getAttribute(\"src\");\n        }\n        if (image.hasAttribute(\"width\")) {\n          result.imageWidth = image.getAttribute(\"width\");\n        }\n        if (image.hasAttribute(\"height\")) {\n          result.imageHeight = image.getAttribute(\"height\");\n        }\n        if (image.hasAttribute(\"alt\")) {\n          result.imageAlt = image.getAttribute(\"alt\");\n        }\n      }\n      return result;\n    };\n    const getSwalIcon = (templateContent) => {\n      const result = {};\n      const icon = templateContent.querySelector(\"swal-icon\");\n      if (icon) {\n        showWarningsForAttributes(icon, [\"type\", \"color\"]);\n        if (icon.hasAttribute(\"type\")) {\n          result.icon = icon.getAttribute(\"type\");\n        }\n        if (icon.hasAttribute(\"color\")) {\n          result.iconColor = icon.getAttribute(\"color\");\n        }\n        result.iconHtml = icon.innerHTML;\n      }\n      return result;\n    };\n    const getSwalInput = (templateContent) => {\n      const result = {};\n      const input = templateContent.querySelector(\"swal-input\");\n      if (input) {\n        showWarningsForAttributes(input, [\"type\", \"label\", \"placeholder\", \"value\"]);\n        result.input = input.getAttribute(\"type\") || \"text\";\n        if (input.hasAttribute(\"label\")) {\n          result.inputLabel = input.getAttribute(\"label\");\n        }\n        if (input.hasAttribute(\"placeholder\")) {\n          result.inputPlaceholder = input.getAttribute(\"placeholder\");\n        }\n        if (input.hasAttribute(\"value\")) {\n          result.inputValue = input.getAttribute(\"value\");\n        }\n      }\n      const inputOptions = templateContent.querySelectorAll(\"swal-input-option\");\n      if (inputOptions.length) {\n        result.inputOptions = {};\n        toArray(inputOptions).forEach((option) => {\n          showWarningsForAttributes(option, [\"value\"]);\n          const optionValue = option.getAttribute(\"value\");\n          const optionName = option.innerHTML;\n          result.inputOptions[optionValue] = optionName;\n        });\n      }\n      return result;\n    };\n    const getSwalStringParams = (templateContent, paramNames) => {\n      const result = {};\n      for (const i in paramNames) {\n        const paramName = paramNames[i];\n        const tag = templateContent.querySelector(paramName);\n        if (tag) {\n          showWarningsForAttributes(tag, []);\n          result[paramName.replace(/^swal-/, \"\")] = tag.innerHTML.trim();\n        }\n      }\n      return result;\n    };\n    const showWarningsForElements = (templateContent) => {\n      const allowedElements = swalStringParams.concat([\"swal-param\", \"swal-button\", \"swal-image\", \"swal-icon\", \"swal-input\", \"swal-input-option\"]);\n      toArray(templateContent.children).forEach((el) => {\n        const tagName = el.tagName.toLowerCase();\n        if (allowedElements.indexOf(tagName) === -1) {\n          warn(\"Unrecognized element <\".concat(tagName, \">\"));\n        }\n      });\n    };\n    const showWarningsForAttributes = (el, allowedAttributes) => {\n      toArray(el.attributes).forEach((attribute) => {\n        if (allowedAttributes.indexOf(attribute.name) === -1) {\n          warn(['Unrecognized attribute \"'.concat(attribute.name, '\" on <').concat(el.tagName.toLowerCase(), \">.\"), \"\".concat(allowedAttributes.length ? \"Allowed attributes are: \".concat(allowedAttributes.join(\", \")) : \"To set the value, use HTML within the element.\")]);\n        }\n      });\n    };\n    var defaultInputValidators = {\n      email: (string, validationMessage) => {\n        return /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z0-9-]{2,24}$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid email address\");\n      },\n      url: (string, validationMessage) => {\n        return /^https?:\\/\\/(www\\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-z]{2,63}\\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(string) ? Promise.resolve() : Promise.resolve(validationMessage || \"Invalid URL\");\n      }\n    };\n    function setDefaultInputValidators(params) {\n      if (!params.inputValidator) {\n        Object.keys(defaultInputValidators).forEach((key) => {\n          if (params.input === key) {\n            params.inputValidator = defaultInputValidators[key];\n          }\n        });\n      }\n    }\n    function validateCustomTargetElement(params) {\n      if (!params.target || typeof params.target === \"string\" && !document.querySelector(params.target) || typeof params.target !== \"string\" && !params.target.appendChild) {\n        warn('Target parameter is not valid, defaulting to \"body\"');\n        params.target = \"body\";\n      }\n    }\n    function setParameters(params) {\n      setDefaultInputValidators(params);\n      if (params.showLoaderOnConfirm && !params.preConfirm) {\n        warn(\"showLoaderOnConfirm is set to true, but preConfirm is not defined.\\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\\nhttps://sweetalert2.github.io/#ajax-request\");\n      }\n      validateCustomTargetElement(params);\n      if (typeof params.title === \"string\") {\n        params.title = params.title.split(\"\\n\").join(\"<br />\");\n      }\n      init(params);\n    }\n    class Timer {\n      constructor(callback, delay) {\n        this.callback = callback;\n        this.remaining = delay;\n        this.running = false;\n        this.start();\n      }\n      start() {\n        if (!this.running) {\n          this.running = true;\n          this.started = new Date();\n          this.id = setTimeout(this.callback, this.remaining);\n        }\n        return this.remaining;\n      }\n      stop() {\n        if (this.running) {\n          this.running = false;\n          clearTimeout(this.id);\n          this.remaining -= new Date().getTime() - this.started.getTime();\n        }\n        return this.remaining;\n      }\n      increase(n) {\n        const running = this.running;\n        if (running) {\n          this.stop();\n        }\n        this.remaining += n;\n        if (running) {\n          this.start();\n        }\n        return this.remaining;\n      }\n      getTimerLeft() {\n        if (this.running) {\n          this.stop();\n          this.start();\n        }\n        return this.remaining;\n      }\n      isRunning() {\n        return this.running;\n      }\n    }\n    const fixScrollbar = () => {\n      if (states.previousBodyPadding !== null) {\n        return;\n      }\n      if (document.body.scrollHeight > window.innerHeight) {\n        states.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue(\"padding-right\"));\n        document.body.style.paddingRight = \"\".concat(states.previousBodyPadding + measureScrollbar(), \"px\");\n      }\n    };\n    const undoScrollbar = () => {\n      if (states.previousBodyPadding !== null) {\n        document.body.style.paddingRight = \"\".concat(states.previousBodyPadding, \"px\");\n        states.previousBodyPadding = null;\n      }\n    };\n    const iOSfix = () => {\n      const iOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || navigator.platform === \"MacIntel\" && navigator.maxTouchPoints > 1;\n      if (iOS && !hasClass(document.body, swalClasses.iosfix)) {\n        const offset = document.body.scrollTop;\n        document.body.style.top = \"\".concat(offset * -1, \"px\");\n        addClass(document.body, swalClasses.iosfix);\n        lockBodyScroll();\n        addBottomPaddingForTallPopups();\n      }\n    };\n    const addBottomPaddingForTallPopups = () => {\n      const ua = navigator.userAgent;\n      const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);\n      const webkit = !!ua.match(/WebKit/i);\n      const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);\n      if (iOSSafari) {\n        const bottomPanelHeight = 44;\n        if (getPopup().scrollHeight > window.innerHeight - bottomPanelHeight) {\n          getContainer().style.paddingBottom = \"\".concat(bottomPanelHeight, \"px\");\n        }\n      }\n    };\n    const lockBodyScroll = () => {\n      const container = getContainer();\n      let preventTouchMove;\n      container.ontouchstart = (e) => {\n        preventTouchMove = shouldPreventTouchMove(e);\n      };\n      container.ontouchmove = (e) => {\n        if (preventTouchMove) {\n          e.preventDefault();\n          e.stopPropagation();\n        }\n      };\n    };\n    const shouldPreventTouchMove = (event) => {\n      const target = event.target;\n      const container = getContainer();\n      if (isStylus(event) || isZoom(event)) {\n        return false;\n      }\n      if (target === container) {\n        return true;\n      }\n      if (!isScrollable(container) && target.tagName !== \"INPUT\" && target.tagName !== \"TEXTAREA\" && !(isScrollable(getHtmlContainer()) && getHtmlContainer().contains(target))) {\n        return true;\n      }\n      return false;\n    };\n    const isStylus = (event) => {\n      return event.touches && event.touches.length && event.touches[0].touchType === \"stylus\";\n    };\n    const isZoom = (event) => {\n      return event.touches && event.touches.length > 1;\n    };\n    const undoIOSfix = () => {\n      if (hasClass(document.body, swalClasses.iosfix)) {\n        const offset = parseInt(document.body.style.top, 10);\n        removeClass(document.body, swalClasses.iosfix);\n        document.body.style.top = \"\";\n        document.body.scrollTop = offset * -1;\n      }\n    };\n    const SHOW_CLASS_TIMEOUT = 10;\n    const openPopup = (params) => {\n      const container = getContainer();\n      const popup = getPopup();\n      if (typeof params.willOpen === \"function\") {\n        params.willOpen(popup);\n      }\n      const bodyStyles = window.getComputedStyle(document.body);\n      const initialBodyOverflow = bodyStyles.overflowY;\n      addClasses$1(container, popup, params);\n      setTimeout(() => {\n        setScrollingVisibility(container, popup);\n      }, SHOW_CLASS_TIMEOUT);\n      if (isModal()) {\n        fixScrollContainer(container, params.scrollbarPadding, initialBodyOverflow);\n        setAriaHidden();\n      }\n      if (!isToast() && !globalState.previousActiveElement) {\n        globalState.previousActiveElement = document.activeElement;\n      }\n      if (typeof params.didOpen === \"function\") {\n        setTimeout(() => params.didOpen(popup));\n      }\n      removeClass(container, swalClasses[\"no-transition\"]);\n    };\n    const swalOpenAnimationFinished = (event) => {\n      const popup = getPopup();\n      if (event.target !== popup) {\n        return;\n      }\n      const container = getContainer();\n      popup.removeEventListener(animationEndEvent, swalOpenAnimationFinished);\n      container.style.overflowY = \"auto\";\n    };\n    const setScrollingVisibility = (container, popup) => {\n      if (animationEndEvent && hasCssAnimation(popup)) {\n        container.style.overflowY = \"hidden\";\n        popup.addEventListener(animationEndEvent, swalOpenAnimationFinished);\n      } else {\n        container.style.overflowY = \"auto\";\n      }\n    };\n    const fixScrollContainer = (container, scrollbarPadding, initialBodyOverflow) => {\n      iOSfix();\n      if (scrollbarPadding && initialBodyOverflow !== \"hidden\") {\n        fixScrollbar();\n      }\n      setTimeout(() => {\n        container.scrollTop = 0;\n      });\n    };\n    const addClasses$1 = (container, popup, params) => {\n      addClass(container, params.showClass.backdrop);\n      popup.style.setProperty(\"opacity\", \"0\", \"important\");\n      show(popup, \"grid\");\n      setTimeout(() => {\n        addClass(popup, params.showClass.popup);\n        popup.style.removeProperty(\"opacity\");\n      }, SHOW_CLASS_TIMEOUT);\n      addClass([document.documentElement, document.body], swalClasses.shown);\n      if (params.heightAuto && params.backdrop && !params.toast) {\n        addClass([document.documentElement, document.body], swalClasses[\"height-auto\"]);\n      }\n    };\n    const showLoading = (buttonToReplace) => {\n      let popup = getPopup();\n      if (!popup) {\n        new Swal2();\n      }\n      popup = getPopup();\n      const loader = getLoader();\n      if (isToast()) {\n        hide(getIcon());\n      } else {\n        replaceButton(popup, buttonToReplace);\n      }\n      show(loader);\n      popup.setAttribute(\"data-loading\", true);\n      popup.setAttribute(\"aria-busy\", true);\n      popup.focus();\n    };\n    const replaceButton = (popup, buttonToReplace) => {\n      const actions = getActions();\n      const loader = getLoader();\n      if (!buttonToReplace && isVisible(getConfirmButton())) {\n        buttonToReplace = getConfirmButton();\n      }\n      show(actions);\n      if (buttonToReplace) {\n        hide(buttonToReplace);\n        loader.setAttribute(\"data-button-to-replace\", buttonToReplace.className);\n      }\n      loader.parentNode.insertBefore(loader, buttonToReplace);\n      addClass([popup, actions], swalClasses.loading);\n    };\n    const handleInputOptionsAndValue = (instance, params) => {\n      if (params.input === \"select\" || params.input === \"radio\") {\n        handleInputOptions(instance, params);\n      } else if ([\"text\", \"email\", \"number\", \"tel\", \"textarea\"].includes(params.input) && (hasToPromiseFn(params.inputValue) || isPromise(params.inputValue))) {\n        showLoading(getConfirmButton());\n        handleInputValue(instance, params);\n      }\n    };\n    const getInputValue = (instance, innerParams) => {\n      const input = instance.getInput();\n      if (!input) {\n        return null;\n      }\n      switch (innerParams.input) {\n        case \"checkbox\":\n          return getCheckboxValue(input);\n        case \"radio\":\n          return getRadioValue(input);\n        case \"file\":\n          return getFileValue(input);\n        default:\n          return innerParams.inputAutoTrim ? input.value.trim() : input.value;\n      }\n    };\n    const getCheckboxValue = (input) => input.checked ? 1 : 0;\n    const getRadioValue = (input) => input.checked ? input.value : null;\n    const getFileValue = (input) => input.files.length ? input.getAttribute(\"multiple\") !== null ? input.files : input.files[0] : null;\n    const handleInputOptions = (instance, params) => {\n      const popup = getPopup();\n      const processInputOptions = (inputOptions) => populateInputOptions[params.input](popup, formatInputOptions(inputOptions), params);\n      if (hasToPromiseFn(params.inputOptions) || isPromise(params.inputOptions)) {\n        showLoading(getConfirmButton());\n        asPromise(params.inputOptions).then((inputOptions) => {\n          instance.hideLoading();\n          processInputOptions(inputOptions);\n        });\n      } else if (typeof params.inputOptions === \"object\") {\n        processInputOptions(params.inputOptions);\n      } else {\n        error(\"Unexpected type of inputOptions! Expected object, Map or Promise, got \".concat(typeof params.inputOptions));\n      }\n    };\n    const handleInputValue = (instance, params) => {\n      const input = instance.getInput();\n      hide(input);\n      asPromise(params.inputValue).then((inputValue) => {\n        input.value = params.input === \"number\" ? parseFloat(inputValue) || 0 : \"\".concat(inputValue);\n        show(input);\n        input.focus();\n        instance.hideLoading();\n      }).catch((err) => {\n        error(\"Error in inputValue promise: \".concat(err));\n        input.value = \"\";\n        show(input);\n        input.focus();\n        instance.hideLoading();\n      });\n    };\n    const populateInputOptions = {\n      select: (popup, inputOptions, params) => {\n        const select = getDirectChildByClass(popup, swalClasses.select);\n        const renderOption = (parent, optionLabel, optionValue) => {\n          const option = document.createElement(\"option\");\n          option.value = optionValue;\n          setInnerHtml(option, optionLabel);\n          option.selected = isSelected(optionValue, params.inputValue);\n          parent.appendChild(option);\n        };\n        inputOptions.forEach((inputOption) => {\n          const optionValue = inputOption[0];\n          const optionLabel = inputOption[1];\n          if (Array.isArray(optionLabel)) {\n            const optgroup = document.createElement(\"optgroup\");\n            optgroup.label = optionValue;\n            optgroup.disabled = false;\n            select.appendChild(optgroup);\n            optionLabel.forEach((o) => renderOption(optgroup, o[1], o[0]));\n          } else {\n            renderOption(select, optionLabel, optionValue);\n          }\n        });\n        select.focus();\n      },\n      radio: (popup, inputOptions, params) => {\n        const radio = getDirectChildByClass(popup, swalClasses.radio);\n        inputOptions.forEach((inputOption) => {\n          const radioValue = inputOption[0];\n          const radioLabel = inputOption[1];\n          const radioInput = document.createElement(\"input\");\n          const radioLabelElement = document.createElement(\"label\");\n          radioInput.type = \"radio\";\n          radioInput.name = swalClasses.radio;\n          radioInput.value = radioValue;\n          if (isSelected(radioValue, params.inputValue)) {\n            radioInput.checked = true;\n          }\n          const label = document.createElement(\"span\");\n          setInnerHtml(label, radioLabel);\n          label.className = swalClasses.label;\n          radioLabelElement.appendChild(radioInput);\n          radioLabelElement.appendChild(label);\n          radio.appendChild(radioLabelElement);\n        });\n        const radios = radio.querySelectorAll(\"input\");\n        if (radios.length) {\n          radios[0].focus();\n        }\n      }\n    };\n    const formatInputOptions = (inputOptions) => {\n      const result = [];\n      if (typeof Map !== \"undefined\" && inputOptions instanceof Map) {\n        inputOptions.forEach((value, key) => {\n          let valueFormatted = value;\n          if (typeof valueFormatted === \"object\") {\n            valueFormatted = formatInputOptions(valueFormatted);\n          }\n          result.push([key, valueFormatted]);\n        });\n      } else {\n        Object.keys(inputOptions).forEach((key) => {\n          let valueFormatted = inputOptions[key];\n          if (typeof valueFormatted === \"object\") {\n            valueFormatted = formatInputOptions(valueFormatted);\n          }\n          result.push([key, valueFormatted]);\n        });\n      }\n      return result;\n    };\n    const isSelected = (optionValue, inputValue) => {\n      return inputValue && inputValue.toString() === optionValue.toString();\n    };\n    const handleConfirmButtonClick = (instance) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      instance.disableButtons();\n      if (innerParams.input) {\n        handleConfirmOrDenyWithInput(instance, \"confirm\");\n      } else {\n        confirm(instance, true);\n      }\n    };\n    const handleDenyButtonClick = (instance) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      instance.disableButtons();\n      if (innerParams.returnInputValueOnDeny) {\n        handleConfirmOrDenyWithInput(instance, \"deny\");\n      } else {\n        deny(instance, false);\n      }\n    };\n    const handleCancelButtonClick = (instance, dismissWith) => {\n      instance.disableButtons();\n      dismissWith(DismissReason.cancel);\n    };\n    const handleConfirmOrDenyWithInput = (instance, type) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      if (!innerParams.input) {\n        return error('The \"input\" parameter is needed to be set when using returnInputValueOn'.concat(capitalizeFirstLetter(type)));\n      }\n      const inputValue = getInputValue(instance, innerParams);\n      if (innerParams.inputValidator) {\n        handleInputValidator(instance, inputValue, type);\n      } else if (!instance.getInput().checkValidity()) {\n        instance.enableButtons();\n        instance.showValidationMessage(innerParams.validationMessage);\n      } else if (type === \"deny\") {\n        deny(instance, inputValue);\n      } else {\n        confirm(instance, inputValue);\n      }\n    };\n    const handleInputValidator = (instance, inputValue, type) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      instance.disableInput();\n      const validationPromise = Promise.resolve().then(() => asPromise(innerParams.inputValidator(inputValue, innerParams.validationMessage)));\n      validationPromise.then((validationMessage) => {\n        instance.enableButtons();\n        instance.enableInput();\n        if (validationMessage) {\n          instance.showValidationMessage(validationMessage);\n        } else if (type === \"deny\") {\n          deny(instance, inputValue);\n        } else {\n          confirm(instance, inputValue);\n        }\n      });\n    };\n    const deny = (instance, value) => {\n      const innerParams = privateProps.innerParams.get(instance || void 0);\n      if (innerParams.showLoaderOnDeny) {\n        showLoading(getDenyButton());\n      }\n      if (innerParams.preDeny) {\n        privateProps.awaitingPromise.set(instance || void 0, true);\n        const preDenyPromise = Promise.resolve().then(() => asPromise(innerParams.preDeny(value, innerParams.validationMessage)));\n        preDenyPromise.then((preDenyValue) => {\n          if (preDenyValue === false) {\n            instance.hideLoading();\n          } else {\n            instance.closePopup({\n              isDenied: true,\n              value: typeof preDenyValue === \"undefined\" ? value : preDenyValue\n            });\n          }\n        }).catch((error$$1) => rejectWith(instance || void 0, error$$1));\n      } else {\n        instance.closePopup({\n          isDenied: true,\n          value\n        });\n      }\n    };\n    const succeedWith = (instance, value) => {\n      instance.closePopup({\n        isConfirmed: true,\n        value\n      });\n    };\n    const rejectWith = (instance, error$$1) => {\n      instance.rejectPromise(error$$1);\n    };\n    const confirm = (instance, value) => {\n      const innerParams = privateProps.innerParams.get(instance || void 0);\n      if (innerParams.showLoaderOnConfirm) {\n        showLoading();\n      }\n      if (innerParams.preConfirm) {\n        instance.resetValidationMessage();\n        privateProps.awaitingPromise.set(instance || void 0, true);\n        const preConfirmPromise = Promise.resolve().then(() => asPromise(innerParams.preConfirm(value, innerParams.validationMessage)));\n        preConfirmPromise.then((preConfirmValue) => {\n          if (isVisible(getValidationMessage()) || preConfirmValue === false) {\n            instance.hideLoading();\n          } else {\n            succeedWith(instance, typeof preConfirmValue === \"undefined\" ? value : preConfirmValue);\n          }\n        }).catch((error$$1) => rejectWith(instance || void 0, error$$1));\n      } else {\n        succeedWith(instance, value);\n      }\n    };\n    const handlePopupClick = (instance, domCache, dismissWith) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      if (innerParams.toast) {\n        handleToastClick(instance, domCache, dismissWith);\n      } else {\n        handleModalMousedown(domCache);\n        handleContainerMousedown(domCache);\n        handleModalClick(instance, domCache, dismissWith);\n      }\n    };\n    const handleToastClick = (instance, domCache, dismissWith) => {\n      domCache.popup.onclick = () => {\n        const innerParams = privateProps.innerParams.get(instance);\n        if (innerParams && (isAnyButtonShown(innerParams) || innerParams.timer || innerParams.input)) {\n          return;\n        }\n        dismissWith(DismissReason.close);\n      };\n    };\n    const isAnyButtonShown = (innerParams) => {\n      return innerParams.showConfirmButton || innerParams.showDenyButton || innerParams.showCancelButton || innerParams.showCloseButton;\n    };\n    let ignoreOutsideClick = false;\n    const handleModalMousedown = (domCache) => {\n      domCache.popup.onmousedown = () => {\n        domCache.container.onmouseup = function(e) {\n          domCache.container.onmouseup = void 0;\n          if (e.target === domCache.container) {\n            ignoreOutsideClick = true;\n          }\n        };\n      };\n    };\n    const handleContainerMousedown = (domCache) => {\n      domCache.container.onmousedown = () => {\n        domCache.popup.onmouseup = function(e) {\n          domCache.popup.onmouseup = void 0;\n          if (e.target === domCache.popup || domCache.popup.contains(e.target)) {\n            ignoreOutsideClick = true;\n          }\n        };\n      };\n    };\n    const handleModalClick = (instance, domCache, dismissWith) => {\n      domCache.container.onclick = (e) => {\n        const innerParams = privateProps.innerParams.get(instance);\n        if (ignoreOutsideClick) {\n          ignoreOutsideClick = false;\n          return;\n        }\n        if (e.target === domCache.container && callIfFunction(innerParams.allowOutsideClick)) {\n          dismissWith(DismissReason.backdrop);\n        }\n      };\n    };\n    const isVisible$1 = () => {\n      return isVisible(getPopup());\n    };\n    const clickConfirm = () => getConfirmButton() && getConfirmButton().click();\n    const clickDeny = () => getDenyButton() && getDenyButton().click();\n    const clickCancel = () => getCancelButton() && getCancelButton().click();\n    const addKeydownHandler = (instance, globalState2, innerParams, dismissWith) => {\n      if (globalState2.keydownTarget && globalState2.keydownHandlerAdded) {\n        globalState2.keydownTarget.removeEventListener(\"keydown\", globalState2.keydownHandler, {\n          capture: globalState2.keydownListenerCapture\n        });\n        globalState2.keydownHandlerAdded = false;\n      }\n      if (!innerParams.toast) {\n        globalState2.keydownHandler = (e) => keydownHandler(instance, e, dismissWith);\n        globalState2.keydownTarget = innerParams.keydownListenerCapture ? window : getPopup();\n        globalState2.keydownListenerCapture = innerParams.keydownListenerCapture;\n        globalState2.keydownTarget.addEventListener(\"keydown\", globalState2.keydownHandler, {\n          capture: globalState2.keydownListenerCapture\n        });\n        globalState2.keydownHandlerAdded = true;\n      }\n    };\n    const setFocus = (innerParams, index, increment) => {\n      const focusableElements = getFocusableElements();\n      if (focusableElements.length) {\n        index = index + increment;\n        if (index === focusableElements.length) {\n          index = 0;\n        } else if (index === -1) {\n          index = focusableElements.length - 1;\n        }\n        return focusableElements[index].focus();\n      }\n      getPopup().focus();\n    };\n    const arrowKeysNextButton = [\"ArrowRight\", \"ArrowDown\"];\n    const arrowKeysPreviousButton = [\"ArrowLeft\", \"ArrowUp\"];\n    const keydownHandler = (instance, e, dismissWith) => {\n      const innerParams = privateProps.innerParams.get(instance);\n      if (!innerParams) {\n        return;\n      }\n      if (innerParams.stopKeydownPropagation) {\n        e.stopPropagation();\n      }\n      if (e.key === \"Enter\") {\n        handleEnter(instance, e, innerParams);\n      } else if (e.key === \"Tab\") {\n        handleTab(e, innerParams);\n      } else if ([...arrowKeysNextButton, ...arrowKeysPreviousButton].includes(e.key)) {\n        handleArrows(e.key);\n      } else if (e.key === \"Escape\") {\n        handleEsc(e, innerParams, dismissWith);\n      }\n    };\n    const handleEnter = (instance, e, innerParams) => {\n      if (!callIfFunction(innerParams.allowEnterKey) || e.isComposing) {\n        return;\n      }\n      if (e.target && instance.getInput() && e.target.outerHTML === instance.getInput().outerHTML) {\n        if ([\"textarea\", \"file\"].includes(innerParams.input)) {\n          return;\n        }\n        clickConfirm();\n        e.preventDefault();\n      }\n    };\n    const handleTab = (e, innerParams) => {\n      const targetElement = e.target;\n      const focusableElements = getFocusableElements();\n      let btnIndex = -1;\n      for (let i = 0; i < focusableElements.length; i++) {\n        if (targetElement === focusableElements[i]) {\n          btnIndex = i;\n          break;\n        }\n      }\n      if (!e.shiftKey) {\n        setFocus(innerParams, btnIndex, 1);\n      } else {\n        setFocus(innerParams, btnIndex, -1);\n      }\n      e.stopPropagation();\n      e.preventDefault();\n    };\n    const handleArrows = (key) => {\n      const confirmButton = getConfirmButton();\n      const denyButton = getDenyButton();\n      const cancelButton = getCancelButton();\n      if (![confirmButton, denyButton, cancelButton].includes(document.activeElement)) {\n        return;\n      }\n      const sibling = arrowKeysNextButton.includes(key) ? \"nextElementSibling\" : \"previousElementSibling\";\n      const buttonToFocus = document.activeElement[sibling];\n      if (buttonToFocus instanceof HTMLElement) {\n        buttonToFocus.focus();\n      }\n    };\n    const handleEsc = (e, innerParams, dismissWith) => {\n      if (callIfFunction(innerParams.allowEscapeKey)) {\n        e.preventDefault();\n        dismissWith(DismissReason.esc);\n      }\n    };\n    const isJqueryElement = (elem) => typeof elem === \"object\" && elem.jquery;\n    const isElement = (elem) => elem instanceof Element || isJqueryElement(elem);\n    const argsToParams = (args) => {\n      const params = {};\n      if (typeof args[0] === \"object\" && !isElement(args[0])) {\n        Object.assign(params, args[0]);\n      } else {\n        [\"title\", \"html\", \"icon\"].forEach((name, index) => {\n          const arg = args[index];\n          if (typeof arg === \"string\" || isElement(arg)) {\n            params[name] = arg;\n          } else if (arg !== void 0) {\n            error(\"Unexpected type of \".concat(name, '! Expected \"string\" or \"Element\", got ').concat(typeof arg));\n          }\n        });\n      }\n      return params;\n    };\n    function fire() {\n      const Swal3 = this;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return new Swal3(...args);\n    }\n    function mixin(mixinParams) {\n      class MixinSwal extends this {\n        _main(params, priorityMixinParams) {\n          return super._main(params, Object.assign({}, mixinParams, priorityMixinParams));\n        }\n      }\n      return MixinSwal;\n    }\n    const getTimerLeft = () => {\n      return globalState.timeout && globalState.timeout.getTimerLeft();\n    };\n    const stopTimer = () => {\n      if (globalState.timeout) {\n        stopTimerProgressBar();\n        return globalState.timeout.stop();\n      }\n    };\n    const resumeTimer = () => {\n      if (globalState.timeout) {\n        const remaining = globalState.timeout.start();\n        animateTimerProgressBar(remaining);\n        return remaining;\n      }\n    };\n    const toggleTimer = () => {\n      const timer = globalState.timeout;\n      return timer && (timer.running ? stopTimer() : resumeTimer());\n    };\n    const increaseTimer = (n) => {\n      if (globalState.timeout) {\n        const remaining = globalState.timeout.increase(n);\n        animateTimerProgressBar(remaining, true);\n        return remaining;\n      }\n    };\n    const isTimerRunning = () => {\n      return globalState.timeout && globalState.timeout.isRunning();\n    };\n    let bodyClickListenerAdded = false;\n    const clickHandlers = {};\n    function bindClickHandler() {\n      let attr = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : \"data-swal-template\";\n      clickHandlers[attr] = this;\n      if (!bodyClickListenerAdded) {\n        document.body.addEventListener(\"click\", bodyClickListener);\n        bodyClickListenerAdded = true;\n      }\n    }\n    const bodyClickListener = (event) => {\n      for (let el = event.target; el && el !== document; el = el.parentNode) {\n        for (const attr in clickHandlers) {\n          const template = el.getAttribute(attr);\n          if (template) {\n            clickHandlers[attr].fire({\n              template\n            });\n            return;\n          }\n        }\n      }\n    };\n    var staticMethods = /* @__PURE__ */ Object.freeze({\n      isValidParameter,\n      isUpdatableParameter,\n      isDeprecatedParameter,\n      argsToParams,\n      isVisible: isVisible$1,\n      clickConfirm,\n      clickDeny,\n      clickCancel,\n      getContainer,\n      getPopup,\n      getTitle,\n      getHtmlContainer,\n      getImage,\n      getIcon,\n      getInputLabel,\n      getCloseButton,\n      getActions,\n      getConfirmButton,\n      getDenyButton,\n      getCancelButton,\n      getLoader,\n      getFooter,\n      getTimerProgressBar,\n      getFocusableElements,\n      getValidationMessage,\n      isLoading,\n      fire,\n      mixin,\n      showLoading,\n      enableLoading: showLoading,\n      getTimerLeft,\n      stopTimer,\n      resumeTimer,\n      toggleTimer,\n      increaseTimer,\n      isTimerRunning,\n      bindClickHandler\n    });\n    function hideLoading() {\n      const innerParams = privateProps.innerParams.get(this);\n      if (!innerParams) {\n        return;\n      }\n      const domCache = privateProps.domCache.get(this);\n      hide(domCache.loader);\n      if (isToast()) {\n        if (innerParams.icon) {\n          show(getIcon());\n        }\n      } else {\n        showRelatedButton(domCache);\n      }\n      removeClass([domCache.popup, domCache.actions], swalClasses.loading);\n      domCache.popup.removeAttribute(\"aria-busy\");\n      domCache.popup.removeAttribute(\"data-loading\");\n      domCache.confirmButton.disabled = false;\n      domCache.denyButton.disabled = false;\n      domCache.cancelButton.disabled = false;\n    }\n    const showRelatedButton = (domCache) => {\n      const buttonToReplace = domCache.popup.getElementsByClassName(domCache.loader.getAttribute(\"data-button-to-replace\"));\n      if (buttonToReplace.length) {\n        show(buttonToReplace[0], \"inline-block\");\n      } else if (allButtonsAreHidden()) {\n        hide(domCache.actions);\n      }\n    };\n    function getInput$1(instance) {\n      const innerParams = privateProps.innerParams.get(instance || this);\n      const domCache = privateProps.domCache.get(instance || this);\n      if (!domCache) {\n        return null;\n      }\n      return getInput(domCache.popup, innerParams.input);\n    }\n    var privateMethods = {\n      swalPromiseResolve: /* @__PURE__ */ new WeakMap(),\n      swalPromiseReject: /* @__PURE__ */ new WeakMap()\n    };\n    function removePopupAndResetState(instance, container, returnFocus, didClose) {\n      if (isToast()) {\n        triggerDidCloseAndDispose(instance, didClose);\n      } else {\n        restoreActiveElement(returnFocus).then(() => triggerDidCloseAndDispose(instance, didClose));\n        globalState.keydownTarget.removeEventListener(\"keydown\", globalState.keydownHandler, {\n          capture: globalState.keydownListenerCapture\n        });\n        globalState.keydownHandlerAdded = false;\n      }\n      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n      if (isSafari) {\n        container.setAttribute(\"style\", \"display:none !important\");\n        container.removeAttribute(\"class\");\n        container.innerHTML = \"\";\n      } else {\n        container.remove();\n      }\n      if (isModal()) {\n        undoScrollbar();\n        undoIOSfix();\n        unsetAriaHidden();\n      }\n      removeBodyClasses();\n    }\n    function removeBodyClasses() {\n      removeClass([document.documentElement, document.body], [swalClasses.shown, swalClasses[\"height-auto\"], swalClasses[\"no-backdrop\"], swalClasses[\"toast-shown\"]]);\n    }\n    function close(resolveValue) {\n      resolveValue = prepareResolveValue(resolveValue);\n      const swalPromiseResolve = privateMethods.swalPromiseResolve.get(this);\n      const didClose = triggerClosePopup(this);\n      if (this.isAwaitingPromise()) {\n        if (!resolveValue.isDismissed) {\n          handleAwaitingPromise(this);\n          swalPromiseResolve(resolveValue);\n        }\n      } else if (didClose) {\n        swalPromiseResolve(resolveValue);\n      }\n    }\n    function isAwaitingPromise() {\n      return !!privateProps.awaitingPromise.get(this);\n    }\n    const triggerClosePopup = (instance) => {\n      const popup = getPopup();\n      if (!popup) {\n        return false;\n      }\n      const innerParams = privateProps.innerParams.get(instance);\n      if (!innerParams || hasClass(popup, innerParams.hideClass.popup)) {\n        return false;\n      }\n      removeClass(popup, innerParams.showClass.popup);\n      addClass(popup, innerParams.hideClass.popup);\n      const backdrop = getContainer();\n      removeClass(backdrop, innerParams.showClass.backdrop);\n      addClass(backdrop, innerParams.hideClass.backdrop);\n      handlePopupAnimation(instance, popup, innerParams);\n      return true;\n    };\n    function rejectPromise(error2) {\n      const rejectPromise2 = privateMethods.swalPromiseReject.get(this);\n      handleAwaitingPromise(this);\n      if (rejectPromise2) {\n        rejectPromise2(error2);\n      }\n    }\n    const handleAwaitingPromise = (instance) => {\n      if (instance.isAwaitingPromise()) {\n        privateProps.awaitingPromise.delete(instance);\n        if (!privateProps.innerParams.get(instance)) {\n          instance._destroy();\n        }\n      }\n    };\n    const prepareResolveValue = (resolveValue) => {\n      if (typeof resolveValue === \"undefined\") {\n        return {\n          isConfirmed: false,\n          isDenied: false,\n          isDismissed: true\n        };\n      }\n      return Object.assign({\n        isConfirmed: false,\n        isDenied: false,\n        isDismissed: false\n      }, resolveValue);\n    };\n    const handlePopupAnimation = (instance, popup, innerParams) => {\n      const container = getContainer();\n      const animationIsSupported = animationEndEvent && hasCssAnimation(popup);\n      if (typeof innerParams.willClose === \"function\") {\n        innerParams.willClose(popup);\n      }\n      if (animationIsSupported) {\n        animatePopup(instance, popup, container, innerParams.returnFocus, innerParams.didClose);\n      } else {\n        removePopupAndResetState(instance, container, innerParams.returnFocus, innerParams.didClose);\n      }\n    };\n    const animatePopup = (instance, popup, container, returnFocus, didClose) => {\n      globalState.swalCloseEventFinishedCallback = removePopupAndResetState.bind(null, instance, container, returnFocus, didClose);\n      popup.addEventListener(animationEndEvent, function(e) {\n        if (e.target === popup) {\n          globalState.swalCloseEventFinishedCallback();\n          delete globalState.swalCloseEventFinishedCallback;\n        }\n      });\n    };\n    const triggerDidCloseAndDispose = (instance, didClose) => {\n      setTimeout(() => {\n        if (typeof didClose === \"function\") {\n          didClose.bind(instance.params)();\n        }\n        instance._destroy();\n      });\n    };\n    function setButtonsDisabled(instance, buttons, disabled) {\n      const domCache = privateProps.domCache.get(instance);\n      buttons.forEach((button) => {\n        domCache[button].disabled = disabled;\n      });\n    }\n    function setInputDisabled(input, disabled) {\n      if (!input) {\n        return false;\n      }\n      if (input.type === \"radio\") {\n        const radiosContainer = input.parentNode.parentNode;\n        const radios = radiosContainer.querySelectorAll(\"input\");\n        for (let i = 0; i < radios.length; i++) {\n          radios[i].disabled = disabled;\n        }\n      } else {\n        input.disabled = disabled;\n      }\n    }\n    function enableButtons() {\n      setButtonsDisabled(this, [\"confirmButton\", \"denyButton\", \"cancelButton\"], false);\n    }\n    function disableButtons() {\n      setButtonsDisabled(this, [\"confirmButton\", \"denyButton\", \"cancelButton\"], true);\n    }\n    function enableInput() {\n      return setInputDisabled(this.getInput(), false);\n    }\n    function disableInput() {\n      return setInputDisabled(this.getInput(), true);\n    }\n    function showValidationMessage(error2) {\n      const domCache = privateProps.domCache.get(this);\n      const params = privateProps.innerParams.get(this);\n      setInnerHtml(domCache.validationMessage, error2);\n      domCache.validationMessage.className = swalClasses[\"validation-message\"];\n      if (params.customClass && params.customClass.validationMessage) {\n        addClass(domCache.validationMessage, params.customClass.validationMessage);\n      }\n      show(domCache.validationMessage);\n      const input = this.getInput();\n      if (input) {\n        input.setAttribute(\"aria-invalid\", true);\n        input.setAttribute(\"aria-describedby\", swalClasses[\"validation-message\"]);\n        focusInput(input);\n        addClass(input, swalClasses.inputerror);\n      }\n    }\n    function resetValidationMessage$1() {\n      const domCache = privateProps.domCache.get(this);\n      if (domCache.validationMessage) {\n        hide(domCache.validationMessage);\n      }\n      const input = this.getInput();\n      if (input) {\n        input.removeAttribute(\"aria-invalid\");\n        input.removeAttribute(\"aria-describedby\");\n        removeClass(input, swalClasses.inputerror);\n      }\n    }\n    function getProgressSteps$1() {\n      const domCache = privateProps.domCache.get(this);\n      return domCache.progressSteps;\n    }\n    function update(params) {\n      const popup = getPopup();\n      const innerParams = privateProps.innerParams.get(this);\n      if (!popup || hasClass(popup, innerParams.hideClass.popup)) {\n        return warn(\"You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.\");\n      }\n      const validUpdatableParams = filterValidParams(params);\n      const updatedParams = Object.assign({}, innerParams, validUpdatableParams);\n      render(this, updatedParams);\n      privateProps.innerParams.set(this, updatedParams);\n      Object.defineProperties(this, {\n        params: {\n          value: Object.assign({}, this.params, params),\n          writable: false,\n          enumerable: true\n        }\n      });\n    }\n    const filterValidParams = (params) => {\n      const validUpdatableParams = {};\n      Object.keys(params).forEach((param) => {\n        if (isUpdatableParameter(param)) {\n          validUpdatableParams[param] = params[param];\n        } else {\n          warn('Invalid parameter to update: \"'.concat(param, '\". Updatable params are listed here: https://github.com/sweetalert2/sweetalert2/blob/master/src/utils/params.js\\n\\nIf you think this parameter should be updatable, request it here: https://github.com/sweetalert2/sweetalert2/issues/new?template=02_feature_request.md'));\n        }\n      });\n      return validUpdatableParams;\n    };\n    function _destroy() {\n      const domCache = privateProps.domCache.get(this);\n      const innerParams = privateProps.innerParams.get(this);\n      if (!innerParams) {\n        disposeWeakMaps(this);\n        return;\n      }\n      if (domCache.popup && globalState.swalCloseEventFinishedCallback) {\n        globalState.swalCloseEventFinishedCallback();\n        delete globalState.swalCloseEventFinishedCallback;\n      }\n      if (globalState.deferDisposalTimer) {\n        clearTimeout(globalState.deferDisposalTimer);\n        delete globalState.deferDisposalTimer;\n      }\n      if (typeof innerParams.didDestroy === \"function\") {\n        innerParams.didDestroy();\n      }\n      disposeSwal(this);\n    }\n    const disposeSwal = (instance) => {\n      disposeWeakMaps(instance);\n      delete instance.params;\n      delete globalState.keydownHandler;\n      delete globalState.keydownTarget;\n      delete globalState.currentInstance;\n    };\n    const disposeWeakMaps = (instance) => {\n      if (instance.isAwaitingPromise()) {\n        unsetWeakMaps(privateProps, instance);\n        privateProps.awaitingPromise.set(instance, true);\n      } else {\n        unsetWeakMaps(privateMethods, instance);\n        unsetWeakMaps(privateProps, instance);\n      }\n    };\n    const unsetWeakMaps = (obj, instance) => {\n      for (const i in obj) {\n        obj[i].delete(instance);\n      }\n    };\n    var instanceMethods = /* @__PURE__ */ Object.freeze({\n      hideLoading,\n      disableLoading: hideLoading,\n      getInput: getInput$1,\n      close,\n      isAwaitingPromise,\n      rejectPromise,\n      closePopup: close,\n      closeModal: close,\n      closeToast: close,\n      enableButtons,\n      disableButtons,\n      enableInput,\n      disableInput,\n      showValidationMessage,\n      resetValidationMessage: resetValidationMessage$1,\n      getProgressSteps: getProgressSteps$1,\n      update,\n      _destroy\n    });\n    let currentInstance;\n    class SweetAlert {\n      constructor() {\n        if (typeof window === \"undefined\") {\n          return;\n        }\n        currentInstance = this;\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        const outerParams = Object.freeze(this.constructor.argsToParams(args));\n        Object.defineProperties(this, {\n          params: {\n            value: outerParams,\n            writable: false,\n            enumerable: true,\n            configurable: true\n          }\n        });\n        const promise = this._main(this.params);\n        privateProps.promise.set(this, promise);\n      }\n      _main(userParams) {\n        let mixinParams = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        showWarningsForParams(Object.assign({}, mixinParams, userParams));\n        if (globalState.currentInstance) {\n          globalState.currentInstance._destroy();\n          if (isModal()) {\n            unsetAriaHidden();\n          }\n        }\n        globalState.currentInstance = this;\n        const innerParams = prepareParams(userParams, mixinParams);\n        setParameters(innerParams);\n        Object.freeze(innerParams);\n        if (globalState.timeout) {\n          globalState.timeout.stop();\n          delete globalState.timeout;\n        }\n        clearTimeout(globalState.restoreFocusTimeout);\n        const domCache = populateDomCache(this);\n        render(this, innerParams);\n        privateProps.innerParams.set(this, innerParams);\n        return swalPromise(this, domCache, innerParams);\n      }\n      then(onFulfilled) {\n        const promise = privateProps.promise.get(this);\n        return promise.then(onFulfilled);\n      }\n      finally(onFinally) {\n        const promise = privateProps.promise.get(this);\n        return promise.finally(onFinally);\n      }\n    }\n    const swalPromise = (instance, domCache, innerParams) => {\n      return new Promise((resolve, reject) => {\n        const dismissWith = (dismiss) => {\n          instance.closePopup({\n            isDismissed: true,\n            dismiss\n          });\n        };\n        privateMethods.swalPromiseResolve.set(instance, resolve);\n        privateMethods.swalPromiseReject.set(instance, reject);\n        domCache.confirmButton.onclick = () => handleConfirmButtonClick(instance);\n        domCache.denyButton.onclick = () => handleDenyButtonClick(instance);\n        domCache.cancelButton.onclick = () => handleCancelButtonClick(instance, dismissWith);\n        domCache.closeButton.onclick = () => dismissWith(DismissReason.close);\n        handlePopupClick(instance, domCache, dismissWith);\n        addKeydownHandler(instance, globalState, innerParams, dismissWith);\n        handleInputOptionsAndValue(instance, innerParams);\n        openPopup(innerParams);\n        setupTimer(globalState, innerParams, dismissWith);\n        initFocus(domCache, innerParams);\n        setTimeout(() => {\n          domCache.container.scrollTop = 0;\n        });\n      });\n    };\n    const prepareParams = (userParams, mixinParams) => {\n      const templateParams = getTemplateParams(userParams);\n      const params = Object.assign({}, defaultParams, mixinParams, templateParams, userParams);\n      params.showClass = Object.assign({}, defaultParams.showClass, params.showClass);\n      params.hideClass = Object.assign({}, defaultParams.hideClass, params.hideClass);\n      return params;\n    };\n    const populateDomCache = (instance) => {\n      const domCache = {\n        popup: getPopup(),\n        container: getContainer(),\n        actions: getActions(),\n        confirmButton: getConfirmButton(),\n        denyButton: getDenyButton(),\n        cancelButton: getCancelButton(),\n        loader: getLoader(),\n        closeButton: getCloseButton(),\n        validationMessage: getValidationMessage(),\n        progressSteps: getProgressSteps()\n      };\n      privateProps.domCache.set(instance, domCache);\n      return domCache;\n    };\n    const setupTimer = (globalState$$1, innerParams, dismissWith) => {\n      const timerProgressBar = getTimerProgressBar();\n      hide(timerProgressBar);\n      if (innerParams.timer) {\n        globalState$$1.timeout = new Timer(() => {\n          dismissWith(\"timer\");\n          delete globalState$$1.timeout;\n        }, innerParams.timer);\n        if (innerParams.timerProgressBar) {\n          show(timerProgressBar);\n          applyCustomClass(timerProgressBar, innerParams, \"timerProgressBar\");\n          setTimeout(() => {\n            if (globalState$$1.timeout && globalState$$1.timeout.running) {\n              animateTimerProgressBar(innerParams.timer);\n            }\n          });\n        }\n      }\n    };\n    const initFocus = (domCache, innerParams) => {\n      if (innerParams.toast) {\n        return;\n      }\n      if (!callIfFunction(innerParams.allowEnterKey)) {\n        return blurActiveElement();\n      }\n      if (!focusButton(domCache, innerParams)) {\n        setFocus(innerParams, -1, 1);\n      }\n    };\n    const focusButton = (domCache, innerParams) => {\n      if (innerParams.focusDeny && isVisible(domCache.denyButton)) {\n        domCache.denyButton.focus();\n        return true;\n      }\n      if (innerParams.focusCancel && isVisible(domCache.cancelButton)) {\n        domCache.cancelButton.focus();\n        return true;\n      }\n      if (innerParams.focusConfirm && isVisible(domCache.confirmButton)) {\n        domCache.confirmButton.focus();\n        return true;\n      }\n      return false;\n    };\n    const blurActiveElement = () => {\n      if (document.activeElement instanceof HTMLElement && typeof document.activeElement.blur === \"function\") {\n        document.activeElement.blur();\n      }\n    };\n    Object.assign(SweetAlert.prototype, instanceMethods);\n    Object.assign(SweetAlert, staticMethods);\n    Object.keys(instanceMethods).forEach((key) => {\n      SweetAlert[key] = function() {\n        if (currentInstance) {\n          return currentInstance[key](...arguments);\n        }\n      };\n    });\n    SweetAlert.DismissReason = DismissReason;\n    SweetAlert.version = \"11.4.0\";\n    const Swal2 = SweetAlert;\n    Swal2.default = Swal2;\n    return Swal2;\n  });\n  if (typeof commonjsGlobal !== \"undefined\" && commonjsGlobal.Sweetalert2) {\n    commonjsGlobal.swal = commonjsGlobal.sweetAlert = commonjsGlobal.Swal = commonjsGlobal.SweetAlert = commonjsGlobal.Sweetalert2;\n  }\n})(sweetalert2);\nvar Swal = sweetalert2.exports;\nclass VueSweetalert2 {\n  static install(vue, options = {}) {\n    var _a;\n    const swalLocalInstance = Swal.mixin(options);\n    const swalFunction = function(...args) {\n      return swalLocalInstance.fire.call(swalLocalInstance, ...args);\n    };\n    Object.assign(swalFunction, Swal);\n    Object.keys(Swal).filter((key) => typeof Swal[key] === \"function\").forEach((methodName) => {\n      swalFunction[methodName] = swalLocalInstance[methodName].bind(swalLocalInstance);\n    });\n    if (((_a = vue.config) == null ? void 0 : _a.globalProperties) && !vue.config.globalProperties.$swal) {\n      vue.config.globalProperties.$swal = swalFunction;\n      vue.provide(\"$swal\", swalFunction);\n    } else if (!Object.prototype.hasOwnProperty.call(vue, \"$swal\")) {\n      vue.prototype.$swal = swalFunction;\n      vue[\"swal\"] = swalFunction;\n    }\n  }\n}\nexport { VueSweetalert2 as default };\n",
      "start": 1700848819192,
      "end": 1700848819710,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1700848819710,
      "end": 1700848819710,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1700848819711,
      "end": 1700848819711,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700848819711,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1700848819712,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1700848819712,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1700848819712,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1700848819712,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1700848819712,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1700848819712,
      "end": 1700848819712,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1700848819712,
      "end": 1700848819727,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1700848819727,
      "end": 1700848819727,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1700848819727,
      "end": 1700848819727,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1700848819727,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1700848819728,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1700848819728,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1700848819728,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1700848819728,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1700848819728,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1700848819728,
      "end": 1700848819728,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1700848819728,
      "end": 1700848819729,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1700848819729,
      "end": 1700848819729,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1700848819729,
      "end": 1700848819729,
      "order": "normal"
    }
  ]
}
