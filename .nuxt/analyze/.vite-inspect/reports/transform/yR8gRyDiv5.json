{
  "resolvedId": "C:/Users/Ireedui/Desktop/additional/tsg/front-latest/node_modules/vue3-tour/dist/vue3-tour.es.js",
  "transforms": [
    {
      "name": "vite:load-fallback",
      "result": "import { ref, computed, onMounted, getCurrentInstance, onBeforeUnmount, resolveComponent, openBlock, createElementBlock, renderSlot, createBlock, createCommentVNode, onUnmounted, normalizeClass, createElementVNode, toDisplayString, withModifiers } from \"vue\";\nconst DEFAULT_CALLBACKS = {\n  onStart: () => {\n  },\n  onPreviousStep: (currentStep) => {\n  },\n  onNextStep: (currentStep) => {\n  },\n  onStop: () => {\n  },\n  onSkip: () => {\n  },\n  onFinish: () => {\n  }\n};\nconst DEFAULT_OPTIONS$1 = {\n  highlight: false,\n  labels: {\n    buttonSkip: \"Skip tour\",\n    buttonPrevious: \"Previous\",\n    buttonNext: \"Next\",\n    buttonStop: \"Finish\"\n  },\n  enabledButtons: {\n    buttonSkip: true,\n    buttonPrevious: true,\n    buttonNext: true,\n    buttonStop: true\n  },\n  startTimeout: 0,\n  useKeyboardNavigation: true,\n  enabledNavigationKeys: {\n    ESCAPE: true,\n    ARROW_RIGHT: true,\n    ARROW_LEFT: true\n  },\n  debug: false\n};\nconst HIGHLIGHT = {\n  CLASSES: {\n    ACTIVE: \"v-tour--active\",\n    TARGET_HIGHLIGHTED: \"v-tour__target--highlighted\",\n    TARGET_RELATIVE: \"v-tour__target--relative\"\n  },\n  TRANSITION: \"box-shadow 0s ease-in-out 0s\",\n  useKeyboardNavigation: true,\n  startTimeout: 0,\n  stopOnTargetNotFound: true\n};\nconst DEFAULT_STEP_OPTIONS = {\n  enableScrolling: true,\n  highlight: DEFAULT_OPTIONS$1.highlight,\n  enabledButtons: DEFAULT_OPTIONS$1.enabledButtons,\n  modifiers: [\n    {\n      name: \"offset\",\n      options: {\n        offset: ({ placement }) => {\n          if (placement === \"top\" || placement === \"bottom\") {\n            return [0, 8];\n          } else {\n            return [8, 0];\n          }\n        }\n      }\n    }\n  ],\n  placement: \"bottom\"\n};\nconst KEYS = {\n  ARROW_RIGHT: 39,\n  ARROW_LEFT: 37,\n  ESCAPE: 27\n};\nvar VTour_vue_vue_type_style_index_0_lang = \"\";\nvar _export_sfc = (sfc, props2) => {\n  const target = sfc.__vccOpts || sfc;\n  for (const [key, val] of props2) {\n    target[key] = val;\n  }\n  return target;\n};\nconst _sfc_main$1 = {\n  name: \"v-tour\",\n  props: {\n    steps: {\n      type: Array,\n      default: () => []\n    },\n    name: {\n      type: String\n    },\n    options: {\n      type: Object,\n      default: () => {\n        return DEFAULT_OPTIONS$1;\n      }\n    },\n    callbacks: {\n      type: Object,\n      default: () => {\n        return DEFAULT_CALLBACKS;\n      }\n    }\n  },\n  setup(props2, ctx) {\n    const currentStep = ref(-1);\n    const customOptions = computed(() => {\n      return {\n        ...DEFAULT_OPTIONS$1,\n        ...props2.options\n      };\n    });\n    const customCallbacks = computed(() => {\n      return {\n        ...DEFAULT_CALLBACKS,\n        ...props2.callbacks\n      };\n    });\n    const isRunning = computed(() => currentStep.value > -1 && currentStep.value < numberOfSteps.value);\n    const isFirst = computed(() => currentStep.value === 0);\n    const isLast = computed(() => currentStep.value === props2.steps.length - 1);\n    const numberOfSteps = computed(() => props2.steps.length);\n    const step = computed(() => props2.steps[currentStep.value]);\n    const start2 = async (startStep) => {\n      startStep = typeof startStep !== \"undefined\" ? parseInt(startStep, 10) : 0;\n      let step2 = props2.steps[startStep];\n      let process = () => new Promise((resolve, reject) => {\n        setTimeout(() => {\n          customCallbacks.value.onStart();\n          currentStep.value = startStep;\n          resolve();\n        }, customOptions.value.startTimeout);\n      });\n      if (typeof step2.before !== \"undefined\") {\n        try {\n          await step2.before(\"start\");\n        } catch (e) {\n          return Promise.reject(e);\n        }\n      }\n      await process();\n      return Promise.resolve();\n    };\n    const previousStep = async () => {\n      let futureStep = currentStep.value - 1;\n      let process = () => new Promise((resolve, reject) => {\n        customCallbacks.value.onPreviousStep(currentStep.value);\n        currentStep.value = futureStep;\n        resolve();\n      });\n      if (futureStep > -1) {\n        let step2 = props2.steps[futureStep];\n        if (typeof step2.before !== \"undefined\") {\n          try {\n            await step2.before(\"previous\");\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n        await process();\n      }\n      return Promise.resolve();\n    };\n    const nextStep = async () => {\n      let futureStep = currentStep.value + 1;\n      let process = () => new Promise((resolve, reject) => {\n        customCallbacks.value.onNextStep(currentStep.value);\n        currentStep.value = futureStep;\n        resolve();\n      });\n      if (futureStep < numberOfSteps.value && currentStep.value !== -1) {\n        let step2 = props2.steps[futureStep];\n        if (typeof step2.before !== \"undefined\") {\n          try {\n            await step2.before(\"next\");\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n        await process();\n      }\n      return Promise.resolve();\n    };\n    const stop = () => {\n      customCallbacks.value.onStop();\n      document.body.classList.remove(\"v-tour--active\");\n      currentStep.value = -1;\n    };\n    const skip = () => {\n      customCallbacks.value.onSkip();\n      stop();\n    };\n    const finish = () => {\n      customCallbacks.value.onFinish();\n      stop();\n    };\n    const handleKeyup = (e) => {\n      if (customOptions.value.debug) {\n        console.log(\"[Vue Tour] A keyup event occured:\", e);\n      }\n      switch (e.keyCode) {\n        case KEYS.ARROW_RIGHT:\n          isKeyEnabled(\"ARROW_RIGHT\") && nextStep();\n          break;\n        case KEYS.ARROW_LEFT:\n          isKeyEnabled(\"ARROW_LEFT\") && previousStep();\n          break;\n        case KEYS.ESCAPE:\n          isKeyEnabled(\"ESCAPE\") && stop();\n          break;\n      }\n    };\n    const isKeyEnabled = (key) => {\n      const { enabledNavigationKeys } = customOptions.value;\n      return enabledNavigationKeys.hasOwnProperty(key) ? enabledNavigationKeys[key] : true;\n    };\n    onMounted(() => {\n      const app = getCurrentInstance();\n      app.appContext.config.globalProperties.$tours[props2.name] = { step, start: start2, isRunning, customOptions, currentStep, isFirst, isLast, previousStep, nextStep, stop, skip, finish, numberOfSteps };\n      if (customOptions.value.useKeyboardNavigation) {\n        window.addEventListener(\"keyup\", handleKeyup);\n      }\n    });\n    onBeforeUnmount(() => {\n      if (customOptions.value.useKeyboardNavigation) {\n        window.removeEventListener(\"keyup\", handleKeyup);\n      }\n    });\n    return { customOptions, currentStep, isFirst, isLast, previousStep, nextStep, stop, skip, finish };\n  }\n};\nconst _hoisted_1$1 = { class: \"v-tour\" };\nfunction _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {\n  const _component_v_step = resolveComponent(\"v-step\");\n  return openBlock(), createElementBlock(\"div\", _hoisted_1$1, [\n    renderSlot(_ctx.$slots, \"default\", {\n      currentStep: $setup.currentStep,\n      steps: $props.steps,\n      previousStep: $setup.previousStep,\n      nextStep: $setup.nextStep,\n      stop: $setup.stop,\n      skip: $setup.skip,\n      finish: $setup.finish,\n      isFirst: $setup.isFirst,\n      isLast: $setup.isLast,\n      labels: $setup.customOptions.labels,\n      enabledButtons: $setup.customOptions.enabledButtons,\n      highlight: $setup.customOptions.highlight,\n      debug: $setup.customOptions.debug\n    }, () => [\n      $props.steps[$setup.currentStep] ? (openBlock(), createBlock(_component_v_step, {\n        step: $props.steps[$setup.currentStep],\n        key: $setup.currentStep,\n        \"previous-step\": $setup.previousStep,\n        \"next-step\": $setup.nextStep,\n        stop: $setup.stop,\n        skip: $setup.skip,\n        finish: $setup.finish,\n        \"is-first\": $setup.isFirst,\n        \"is-last\": $setup.isLast,\n        labels: $setup.customOptions.labels,\n        \"enabled-buttons\": $setup.customOptions.enabledButtons,\n        highlight: $setup.customOptions.highlight,\n        \"stop-on-fail\": $setup.customOptions.stopOnTargetNotFound,\n        debug: $setup.customOptions.debug,\n        onTargetNotFound: _cache[0] || (_cache[0] = ($event) => _ctx.$emit(\"targetNotFound\", $event))\n      }, null, 8, [\"step\", \"previous-step\", \"next-step\", \"stop\", \"skip\", \"finish\", \"is-first\", \"is-last\", \"labels\", \"enabled-buttons\", \"highlight\", \"stop-on-fail\", \"debug\"])) : createCommentVNode(\"\", true)\n    ])\n  ]);\n}\nvar VTour = /* @__PURE__ */ _export_sfc(_sfc_main$1, [[\"render\", _sfc_render$1]]);\nvar top = \"top\";\nvar bottom = \"bottom\";\nvar right = \"right\";\nvar left = \"left\";\nvar auto = \"auto\";\nvar basePlacements = [top, bottom, right, left];\nvar start = \"start\";\nvar end = \"end\";\nvar clippingParents = \"clippingParents\";\nvar viewport = \"viewport\";\nvar popper = \"popper\";\nvar reference = \"reference\";\nvar variationPlacements = /* @__PURE__ */ basePlacements.reduce(function(acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar placements = /* @__PURE__ */ [].concat(basePlacements, [auto]).reduce(function(acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nvar beforeRead = \"beforeRead\";\nvar read = \"read\";\nvar afterRead = \"afterRead\";\nvar beforeMain = \"beforeMain\";\nvar main = \"main\";\nvar afterMain = \"afterMain\";\nvar beforeWrite = \"beforeWrite\";\nvar write = \"write\";\nvar afterWrite = \"afterWrite\";\nvar modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\nfunction getNodeName(element) {\n  return element ? (element.nodeName || \"\").toLowerCase() : null;\n}\nfunction getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n  if (node.toString() !== \"[object Window]\") {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n  return node;\n}\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\nfunction isShadowRoot(node) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function(name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name];\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    }\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function(name2) {\n      var value = attributes[name2];\n      if (value === false) {\n        element.removeAttribute(name2);\n      } else {\n        element.setAttribute(name2, value === true ? \"\" : value);\n      }\n    });\n  });\n}\nfunction effect$2(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: \"0\",\n      top: \"0\",\n      margin: \"0\"\n    },\n    arrow: {\n      position: \"absolute\"\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n  return function() {\n    Object.keys(state.elements).forEach(function(name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);\n      var style = styleProperties.reduce(function(style2, property) {\n        style2[property] = \"\";\n        return style2;\n      }, {});\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function(attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n}\nvar applyStyles$1 = {\n  name: \"applyStyles\",\n  enabled: true,\n  phase: \"write\",\n  fn: applyStyles,\n  effect: effect$2,\n  requires: [\"computeStyles\"]\n};\nfunction getBasePlacement(placement) {\n  return placement.split(\"-\")[0];\n}\nvar max = Math.max;\nvar min = Math.min;\nvar round = Math.round;\nfunction getUAString() {\n  var uaData = navigator.userAgentData;\n  if (uaData != null && uaData.brands) {\n    return uaData.brands.map(function(item) {\n      return item.brand + \"/\" + item.version;\n    }).join(\" \");\n  }\n  return navigator.userAgent;\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n  var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element);\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width,\n    height\n  };\n}\nfunction contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode();\n  if (parent.contains(child)) {\n    return true;\n  } else if (rootNode && isShadowRoot(rootNode)) {\n    var next = child;\n    do {\n      if (next && parent.isSameNode(next)) {\n        return true;\n      }\n      next = next.parentNode || next.host;\n    } while (next);\n  }\n  return false;\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].indexOf(getNodeName(element)) >= 0;\n}\nfunction getDocumentElement(element) {\n  return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n}\nfunction getParentNode(element) {\n  if (getNodeName(element) === \"html\") {\n    return element;\n  }\n  return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);\n}\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === \"fixed\") {\n    return null;\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n  if (isIE && isHTMLElement(element)) {\n    var elementCss = getComputedStyle(element);\n    if (elementCss.position === \"fixed\") {\n      return null;\n    }\n  }\n  var currentNode = getParentNode(element);\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n  while (isHTMLElement(currentNode) && [\"html\", \"body\"].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode);\n    if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\"transform\", \"perspective\"].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n  return null;\n}\nfunction getOffsetParent(element) {\n  var window2 = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle(offsetParent).position === \"static\")) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock(element) || window2;\n}\nfunction getMainAxisFromPlacement(placement) {\n  return [\"top\", \"bottom\"].indexOf(placement) >= 0 ? \"x\" : \"y\";\n}\nfunction within(min$1, value, max$1) {\n  return max(min$1, min(value, max$1));\n}\nfunction withinMaxClamp(min2, value, max2) {\n  var v = within(min2, value, max2);\n  return v > max2 ? max2 : v;\n}\nfunction getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}\nfunction mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}\nfunction expandToHashMap(value, keys) {\n  return keys.reduce(function(hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}\nvar toPaddingObject = function toPaddingObject2(padding, state) {\n  padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n};\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n  var state = _ref.state, name = _ref.name, options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? \"height\" : \"width\";\n  if (!arrowElement || !popperOffsets2) {\n    return;\n  }\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === \"y\" ? top : left;\n  var maxProp = axis === \"y\" ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets2[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets2[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2;\n  var min2 = paddingObject[minProp];\n  var max2 = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset2 = within(min2, center, max2);\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset2, _state$modifiersData$.centerOffset = offset2 - center, _state$modifiersData$);\n}\nfunction effect$1(_ref2) {\n  var state = _ref2.state, options = _ref2.options;\n  var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n  if (arrowElement == null) {\n    return;\n  }\n  if (typeof arrowElement === \"string\") {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n    if (!arrowElement) {\n      return;\n    }\n  }\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n  state.elements.arrow = arrowElement;\n}\nvar arrow$1 = {\n  name: \"arrow\",\n  enabled: true,\n  phase: \"main\",\n  fn: arrow,\n  effect: effect$1,\n  requires: [\"popperOffsets\"],\n  requiresIfExists: [\"preventOverflow\"]\n};\nfunction getVariation(placement) {\n  return placement.split(\"-\")[1];\n}\nvar unsetSides = {\n  top: \"auto\",\n  right: \"auto\",\n  bottom: \"auto\",\n  left: \"auto\"\n};\nfunction roundOffsetsByDPR(_ref) {\n  var x = _ref.x, y = _ref.y;\n  var win = window;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\nfunction mapToStyles(_ref2) {\n  var _Object$assign2;\n  var popper2 = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n  var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n    x,\n    y\n  }) : {\n    x,\n    y\n  };\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty(\"x\");\n  var hasY = offsets.hasOwnProperty(\"y\");\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper2);\n    var heightProp = \"clientHeight\";\n    var widthProp = \"clientWidth\";\n    if (offsetParent === getWindow(popper2)) {\n      offsetParent = getDocumentElement(popper2);\n      if (getComputedStyle(offsetParent).position !== \"static\" && position === \"absolute\") {\n        heightProp = \"scrollHeight\";\n        widthProp = \"scrollWidth\";\n      }\n    }\n    offsetParent = offsetParent;\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n  var commonStyles = Object.assign({\n    position\n  }, adaptive && unsetSides);\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x,\n    y\n  }) : {\n    x,\n    y\n  };\n  x = _ref4.x;\n  y = _ref4.y;\n  if (gpuAcceleration) {\n    var _Object$assign;\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n}\nfunction computeStyles(_ref5) {\n  var state = _ref5.state, options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration,\n    isFixed: state.options.strategy === \"fixed\"\n  };\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive,\n      roundOffsets\n    })));\n  }\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: \"absolute\",\n      adaptive: false,\n      roundOffsets\n    })));\n  }\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-placement\": state.placement\n  });\n}\nvar computeStyles$1 = {\n  name: \"computeStyles\",\n  enabled: true,\n  phase: \"beforeWrite\",\n  fn: computeStyles,\n  data: {}\n};\nvar passive = {\n  passive: true\n};\nfunction effect(_ref) {\n  var state = _ref.state, instance = _ref.instance, options = _ref.options;\n  var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n  var window2 = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n  if (scroll) {\n    scrollParents.forEach(function(scrollParent) {\n      scrollParent.addEventListener(\"scroll\", instance.update, passive);\n    });\n  }\n  if (resize) {\n    window2.addEventListener(\"resize\", instance.update, passive);\n  }\n  return function() {\n    if (scroll) {\n      scrollParents.forEach(function(scrollParent) {\n        scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n      });\n    }\n    if (resize) {\n      window2.removeEventListener(\"resize\", instance.update, passive);\n    }\n  };\n}\nvar eventListeners = {\n  name: \"eventListeners\",\n  enabled: true,\n  phase: \"write\",\n  fn: function fn() {\n  },\n  effect,\n  data: {}\n};\nvar hash$1 = {\n  left: \"right\",\n  right: \"left\",\n  bottom: \"top\",\n  top: \"bottom\"\n};\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function(matched) {\n    return hash$1[matched];\n  });\n}\nvar hash = {\n  start: \"end\",\n  end: \"start\"\n};\nfunction getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function(matched) {\n    return hash[matched];\n  });\n}\nfunction getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft,\n    scrollTop\n  };\n}\nfunction getWindowScrollBarX(element) {\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}\nfunction getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x: x + getWindowScrollBarX(element),\n    y\n  };\n}\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n  if (getComputedStyle(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction isScrollParent(element) {\n  var _getComputedStyle = getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}\nfunction getScrollParent(node) {\n  if ([\"html\", \"body\", \"#document\"].indexOf(getNodeName(node)) >= 0) {\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n  return getScrollParent(getParentNode(node));\n}\nfunction listScrollParents(element, list) {\n  var _element$ownerDocumen;\n  if (list === void 0) {\n    list = [];\n  }\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n}\nfunction rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\nfunction getClippingParents(element) {\n  var clippingParents2 = listScrollParents(getParentNode(element));\n  var canEscapeClipping = [\"absolute\", \"fixed\"].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n  if (!isElement(clipperElement)) {\n    return [];\n  }\n  return clippingParents2.filter(function(clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n  });\n}\nfunction getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents2 = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents2[0];\n  var clippingRect = clippingParents2.reduce(function(accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}\nfunction computeOffsets(_ref) {\n  var reference2 = _ref.reference, element = _ref.element, placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference2.x + reference2.width / 2 - element.width / 2;\n  var commonY = reference2.y + reference2.height / 2 - element.height / 2;\n  var offsets;\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference2.y - element.height\n      };\n      break;\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference2.y + reference2.height\n      };\n      break;\n    case right:\n      offsets = {\n        x: reference2.x + reference2.width,\n        y: commonY\n      };\n      break;\n    case left:\n      offsets = {\n        x: reference2.x - element.width,\n        y: commonY\n      };\n      break;\n    default:\n      offsets = {\n        x: reference2.x,\n        y: reference2.y\n      };\n  }\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n  if (mainAxis != null) {\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference2[len] / 2 - element[len] / 2);\n        break;\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference2[len] / 2 - element[len] / 2);\n        break;\n    }\n  }\n  return offsets;\n}\nfunction detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets2 = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: \"absolute\",\n    placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets2));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset;\n  if (elementContext === popper && offsetData) {\n    var offset2 = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function(key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? \"y\" : \"x\";\n      overflowOffsets[key] += offset2[axis] * multiply;\n    });\n  }\n  return overflowOffsets;\n}\nfunction computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement2) {\n    return getVariation(placement2) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements$1.filter(function(placement2) {\n    return allowedAutoPlacements.indexOf(placement2) >= 0;\n  });\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements$1;\n  }\n  var overflows = allowedPlacements.reduce(function(acc, placement2) {\n    acc[placement2] = detectOverflow(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding\n    })[getBasePlacement(placement2)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function(a, b) {\n    return overflows[a] - overflows[b];\n  });\n}\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\nfunction flip(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements2 = [preferredPlacement].concat(fallbackPlacements).reduce(function(acc, placement2) {\n    return acc.concat(getBasePlacement(placement2) === auto ? computeAutoPlacement(state, {\n      placement: placement2,\n      boundary,\n      rootBoundary,\n      padding,\n      flipVariations,\n      allowedAutoPlacements\n    }) : placement2);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = /* @__PURE__ */ new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements2[0];\n  for (var i = 0; i < placements2.length; i++) {\n    var placement = placements2[i];\n    var _basePlacement = getBasePlacement(placement);\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? \"width\" : \"height\";\n    var overflow = detectOverflow(state, {\n      placement,\n      boundary,\n      rootBoundary,\n      altBoundary,\n      padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n    if (checks.every(function(check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n    checksMap.set(placement, checks);\n  }\n  if (makeFallbackChecks) {\n    var numberOfChecks = flipVariations ? 3 : 1;\n    var _loop = function _loop2(_i2) {\n      var fittingPlacement = placements2.find(function(placement2) {\n        var checks2 = checksMap.get(placement2);\n        if (checks2) {\n          return checks2.slice(0, _i2).every(function(check) {\n            return check;\n          });\n        }\n      });\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n      if (_ret === \"break\")\n        break;\n    }\n  }\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n}\nvar flip$1 = {\n  name: \"flip\",\n  enabled: true,\n  phase: \"main\",\n  fn: flip,\n  requiresIfExists: [\"offset\"],\n  data: {\n    _skip: false\n  }\n};\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function(side) {\n    return overflow[side] >= 0;\n  });\n}\nfunction hide(_ref) {\n  var state = _ref.state, name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: \"reference\"\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets,\n    popperEscapeOffsets,\n    isReferenceHidden,\n    hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    \"data-popper-reference-hidden\": isReferenceHidden,\n    \"data-popper-escaped\": hasPopperEscaped\n  });\n}\nvar hide$1 = {\n  name: \"hide\",\n  enabled: true,\n  phase: \"main\",\n  requiresIfExists: [\"preventOverflow\"],\n  fn: hide\n};\nfunction distanceAndSkiddingToXY(placement, rects, offset2) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n  var _ref = typeof offset2 === \"function\" ? offset2(Object.assign({}, rects, {\n    placement\n  })) : offset2, skidding = _ref[0], distance = _ref[1];\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\nfunction offset(_ref2) {\n  var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n  var _options$offset = options.offset, offset2 = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function(acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset2);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n  state.modifiersData[name] = data;\n}\nvar offset$1 = {\n  name: \"offset\",\n  enabled: true,\n  phase: \"main\",\n  requires: [\"popperOffsets\"],\n  fn: offset\n};\nfunction popperOffsets(_ref) {\n  var state = _ref.state, name = _ref.name;\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: \"absolute\",\n    placement: state.placement\n  });\n}\nvar popperOffsets$1 = {\n  name: \"popperOffsets\",\n  enabled: true,\n  phase: \"read\",\n  fn: popperOffsets,\n  data: {}\n};\nfunction getAltAxis(axis) {\n  return axis === \"x\" ? \"y\" : \"x\";\n}\nfunction preventOverflow(_ref) {\n  var state = _ref.state, options = _ref.options, name = _ref.name;\n  var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary,\n    rootBoundary,\n    padding,\n    altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets2 = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n  if (!popperOffsets2) {\n    return;\n  }\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n    var mainSide = mainAxis === \"y\" ? top : left;\n    var altSide = mainAxis === \"y\" ? bottom : right;\n    var len = mainAxis === \"y\" ? \"height\" : \"width\";\n    var offset2 = popperOffsets2[mainAxis];\n    var min$1 = offset2 + overflow[mainSide];\n    var max$1 = offset2 - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide];\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset2 + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset2 + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset2, tether ? max(max$1, tetherMax) : max$1);\n    popperOffsets2[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset2;\n  }\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n    var _mainSide = mainAxis === \"x\" ? top : left;\n    var _altSide = mainAxis === \"x\" ? bottom : right;\n    var _offset = popperOffsets2[altAxis];\n    var _len = altAxis === \"y\" ? \"height\" : \"width\";\n    var _min = _offset + overflow[_mainSide];\n    var _max = _offset - overflow[_altSide];\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n    popperOffsets2[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n  state.modifiersData[name] = data;\n}\nvar preventOverflow$1 = {\n  name: \"preventOverflow\",\n  enabled: true,\n  phase: \"main\",\n  fn: preventOverflow,\n  requiresIfExists: [\"offset\"]\n};\nfunction getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}\nfunction getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n}\nfunction getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== \"body\" || isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction order(modifiers) {\n  var map = /* @__PURE__ */ new Map();\n  var visited = /* @__PURE__ */ new Set();\n  var result = [];\n  modifiers.forEach(function(modifier) {\n    map.set(modifier.name, modifier);\n  });\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function(dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n  modifiers.forEach(function(modifier) {\n    if (!visited.has(modifier.name)) {\n      sort(modifier);\n    }\n  });\n  return result;\n}\nfunction orderModifiers(modifiers) {\n  var orderedModifiers = order(modifiers);\n  return modifierPhases.reduce(function(acc, phase) {\n    return acc.concat(orderedModifiers.filter(function(modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}\nfunction debounce(fn2) {\n  var pending;\n  return function() {\n    if (!pending) {\n      pending = new Promise(function(resolve) {\n        Promise.resolve().then(function() {\n          pending = void 0;\n          resolve(fn2());\n        });\n      });\n    }\n    return pending;\n  };\n}\nfunction mergeByName(modifiers) {\n  var merged = modifiers.reduce(function(merged2, current) {\n    var existing = merged2[current.name];\n    merged2[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged2;\n  }, {});\n  return Object.keys(merged).map(function(key) {\n    return merged[key];\n  });\n}\nvar DEFAULT_OPTIONS = {\n  placement: \"bottom\",\n  modifiers: [],\n  strategy: \"absolute\"\n};\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  return !args.some(function(element) {\n    return !(element && typeof element.getBoundingClientRect === \"function\");\n  });\n}\nfunction popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n  var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers2 = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper2(reference2, popper2, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n    var state = {\n      placement: \"bottom\",\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference2,\n        popper: popper2\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options2 = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options2);\n        state.scrollParents = {\n          reference: isElement(reference2) ? listScrollParents(reference2) : reference2.contextElement ? listScrollParents(reference2.contextElement) : [],\n          popper: listScrollParents(popper2)\n        };\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers2, state.options.modifiers)));\n        state.orderedModifiers = orderedModifiers.filter(function(m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n        var _state$elements = state.elements, reference3 = _state$elements.reference, popper3 = _state$elements.popper;\n        if (!areValidElements(reference3, popper3)) {\n          return;\n        }\n        state.rects = {\n          reference: getCompositeRect(reference3, getOffsetParent(popper3), state.options.strategy === \"fixed\"),\n          popper: getLayoutRect(popper3)\n        };\n        state.reset = false;\n        state.placement = state.options.placement;\n        state.orderedModifiers.forEach(function(modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n          var _state$orderedModifie = state.orderedModifiers[index], fn2 = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n          if (typeof fn2 === \"function\") {\n            state = fn2({\n              state,\n              options: _options,\n              name,\n              instance\n            }) || state;\n          }\n        }\n      },\n      update: debounce(function() {\n        return new Promise(function(resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n    if (!areValidElements(reference2, popper2)) {\n      return instance;\n    }\n    instance.setOptions(options).then(function(state2) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state2);\n      }\n    });\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function(_ref3) {\n        var name = _ref3.name, _ref3$options = _ref3.options, options2 = _ref3$options === void 0 ? {} : _ref3$options, effect2 = _ref3.effect;\n        if (typeof effect2 === \"function\") {\n          var cleanupFn = effect2({\n            state,\n            name,\n            instance,\n            options: options2\n          });\n          var noopFn = function noopFn2() {\n          };\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function(fn2) {\n        return fn2();\n      });\n      effectCleanupFns = [];\n    }\n    return instance;\n  };\n}\nvar defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\nvar createPopper = /* @__PURE__ */ popperGenerator({\n  defaultModifiers\n});\nvar easeInOutQuad = function easeInOutQuad2(t, b, c, d) {\n  t /= d / 2;\n  if (t < 1)\n    return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n};\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function(obj) {\n  return typeof obj;\n} : function(obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nvar jumper = function jumper2() {\n  var element = void 0;\n  var start2 = void 0;\n  var stop = void 0;\n  var offset2 = void 0;\n  var easing = void 0;\n  var a11y = void 0;\n  var distance = void 0;\n  var duration = void 0;\n  var timeStart = void 0;\n  var timeElapsed = void 0;\n  var next = void 0;\n  var callback = void 0;\n  function location() {\n    return window.scrollY || window.pageYOffset;\n  }\n  function top2(element2) {\n    return element2.getBoundingClientRect().top + start2;\n  }\n  function loop(timeCurrent) {\n    if (!timeStart) {\n      timeStart = timeCurrent;\n    }\n    timeElapsed = timeCurrent - timeStart;\n    next = easing(timeElapsed, start2, distance, duration);\n    window.scrollTo(0, next);\n    timeElapsed < duration ? window.requestAnimationFrame(loop) : done();\n  }\n  function done() {\n    window.scrollTo(0, start2 + distance);\n    if (element && a11y) {\n      element.setAttribute(\"tabindex\", \"-1\");\n      element.focus();\n    }\n    if (typeof callback === \"function\") {\n      callback();\n    }\n    timeStart = false;\n  }\n  function jump(target) {\n    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    duration = options.duration || 1e3;\n    offset2 = options.offset || 0;\n    callback = options.callback;\n    easing = options.easing || easeInOutQuad;\n    a11y = options.a11y || false;\n    start2 = location();\n    switch (typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) {\n      case \"number\":\n        element = void 0;\n        a11y = false;\n        stop = start2 + target;\n        break;\n      case \"object\":\n        element = target;\n        stop = top2(element);\n        break;\n      case \"string\":\n        element = document.querySelector(target);\n        stop = top2(element);\n        break;\n    }\n    distance = stop - start2 + offset2;\n    switch (_typeof(options.duration)) {\n      case \"number\":\n        duration = options.duration;\n        break;\n      case \"function\":\n        duration = options.duration(distance);\n        break;\n    }\n    window.requestAnimationFrame(loop);\n  }\n  return jump;\n};\nvar singleton = jumper();\nfunction pad(hash2, len) {\n  while (hash2.length < len) {\n    hash2 = \"0\" + hash2;\n  }\n  return hash2;\n}\nfunction fold(hash2, text) {\n  var i;\n  var chr;\n  var len;\n  if (text.length === 0) {\n    return hash2;\n  }\n  for (i = 0, len = text.length; i < len; i++) {\n    chr = text.charCodeAt(i);\n    hash2 = (hash2 << 5) - hash2 + chr;\n    hash2 |= 0;\n  }\n  return hash2 < 0 ? hash2 * -2 : hash2;\n}\nfunction foldObject(hash2, o, seen) {\n  return Object.keys(o).sort().reduce(foldKey, hash2);\n  function foldKey(hash3, key) {\n    return foldValue(hash3, o[key], key, seen);\n  }\n}\nfunction foldValue(input, value, key, seen) {\n  var hash2 = fold(fold(fold(input, key), toString(value)), typeof value);\n  if (value === null) {\n    return fold(hash2, \"null\");\n  }\n  if (value === void 0) {\n    return fold(hash2, \"undefined\");\n  }\n  if (typeof value === \"object\" || typeof value === \"function\") {\n    if (seen.indexOf(value) !== -1) {\n      return fold(hash2, \"[Circular]\" + key);\n    }\n    seen.push(value);\n    var objHash = foldObject(hash2, value, seen);\n    if (!(\"valueOf\" in value) || typeof value.valueOf !== \"function\") {\n      return objHash;\n    }\n    try {\n      return fold(objHash, String(value.valueOf()));\n    } catch (err) {\n      return fold(objHash, \"[valueOf exception]\" + (err.stack || err.message));\n    }\n  }\n  return fold(hash2, value.toString());\n}\nfunction toString(o) {\n  return Object.prototype.toString.call(o);\n}\nfunction sum(o) {\n  return pad(foldValue(0, o, \"\", []).toString(16), 8);\n}\nvar hashSum = sum;\nvar VStep_vue_vue_type_style_index_0_scoped_true_lang = \"\";\nconst _sfc_main = {\n  name: \"v-step\",\n  props: {\n    step: {\n      type: Object\n    },\n    previousStep: {\n      type: Function\n    },\n    nextStep: {\n      type: Function\n    },\n    stop: {\n      type: Function\n    },\n    skip: {\n      type: Function,\n      default: function() {\n        props.stop();\n      }\n    },\n    finish: {\n      type: Function,\n      default: function() {\n        props.stop();\n      }\n    },\n    isFirst: {\n      type: Boolean\n    },\n    isLast: {\n      type: Boolean\n    },\n    labels: {\n      type: Object\n    },\n    displayMask: {\n      type: Boolean,\n      default: false\n    },\n    enabledButtons: {\n      type: Object\n    },\n    highlight: {\n      type: Boolean\n    },\n    stopOnFail: {\n      type: Boolean\n    },\n    debug: {\n      type: Boolean\n    }\n  },\n  emits: [\"targetNotFound\"],\n  setup(props2, context) {\n    const hash2 = hashSum(props2.step.target);\n    const targetElement = document.querySelector(props2.step.target);\n    const params = computed(() => {\n      return {\n        ...DEFAULT_STEP_OPTIONS,\n        ...{ highlight: props2.highlight },\n        ...{ enabledButtons: Object.assign({}, props2.enabledButtons) },\n        ...props2.step.params\n      };\n    });\n    const isSticky = computed(() => {\n      return !props2.step.target;\n    });\n    const VStep2 = ref(null);\n    const createStep = () => {\n      if (props2.debug) {\n        console.log(\"[Vue Tour] The target element \" + props2.step.target + ' of .v-step[id=\"' + hash2 + '\"] is:', targetElement);\n      }\n      if (isSticky.value) {\n        document.body.appendChild(VStep2);\n      } else {\n        if (targetElement) {\n          enableScrolling();\n          createHighlight();\n          createPopper(targetElement, VStep2.value, params.value);\n        } else {\n          if (props2.debug) {\n            console.error(\"[Vue Tour] The target element \" + props2.step.target + ' of .v-step[id=\"' + hash2 + '\"] does not exist!');\n          }\n          context.emit(\"targetNotFound\", props2.step);\n          if (props2.stopOnFail) {\n            props2.stop();\n          }\n        }\n      }\n    };\n    const enableScrolling = () => {\n      if (params.value.enableScrolling) {\n        if (props2.step.duration || props2.step.offset) {\n          let jumpOptions = {\n            duration: props2.step.duration || 1e3,\n            offset: props2.step.offset || 0,\n            callback: void 0,\n            a11y: false\n          };\n          singleton(targetElement, jumpOptions);\n        } else {\n          targetElement.scrollIntoView({ behavior: \"smooth\" });\n        }\n      }\n    };\n    const isHighlightEnabled = () => {\n      if (props2.debug) {\n        console.log(`[Vue Tour] Highlight is ${params.value.highlight ? \"enabled\" : \"disabled\"} for .v-step[id=\"${hash2}\"]`);\n      }\n      return params.value.highlight;\n    };\n    const createHighlight = () => {\n      if (isHighlightEnabled()) {\n        document.body.classList.add(HIGHLIGHT.CLASSES.ACTIVE);\n        const transitionValue = window.getComputedStyle(targetElement).getPropertyValue(\"transition\");\n        if (transitionValue !== \"all 0s ease 0s\") {\n          targetElement.style.transition = `${transitionValue}, ${HIGHLIGHT.TRANSITION}`;\n        }\n        targetElement.classList.add(HIGHLIGHT.CLASSES.TARGET_HIGHLIGHTED);\n        if (!targetElement.style.position) {\n          targetElement.classList.add(HIGHLIGHT.CLASSES.TARGET_RELATIVE);\n        }\n      } else {\n        document.body.classList.remove(HIGHLIGHT.CLASSES.ACTIVE);\n      }\n    };\n    const removeHighlight = () => {\n      if (isHighlightEnabled()) {\n        const currentTransition = targetElement.style.transition;\n        targetElement.classList.remove(HIGHLIGHT.CLASSES.TARGET_HIGHLIGHTED);\n        targetElement.classList.remove(HIGHLIGHT.CLASSES.TARGET_RELATIVE);\n        if (currentTransition.includes(HIGHLIGHT.TRANSITION)) {\n          setTimeout(() => {\n            targetElement.style.transition = currentTransition.replace(`, ${HIGHLIGHT.TRANSITION}`, \"\");\n          }, 0);\n        }\n      }\n    };\n    const isButtonEnabled = (name) => {\n      return params.value.enabledButtons.hasOwnProperty(name) ? params.value.enabledButtons[name] : true;\n    };\n    onMounted(createStep);\n    onUnmounted(removeHighlight);\n    return { hash: hash2, isButtonEnabled, VStep: VStep2, isSticky };\n  }\n};\nconst _hoisted_1 = [\"id\"];\nconst _hoisted_2 = {\n  key: 0,\n  class: \"v-step__header\"\n};\nconst _hoisted_3 = [\"innerHTML\"];\nconst _hoisted_4 = { class: \"v-step__content\" };\nconst _hoisted_5 = [\"innerHTML\"];\nconst _hoisted_6 = { key: 1 };\nconst _hoisted_7 = { class: \"v-step__buttons\" };\nfunction _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass([{ \"v-step--sticky\": $setup.isSticky }, \"v-step\"]),\n    id: \"v-step-\" + $setup.hash,\n    ref: \"VStep\"\n  }, [\n    renderSlot(_ctx.$slots, \"header\", {}, () => [\n      $props.step.header ? (openBlock(), createElementBlock(\"div\", _hoisted_2, [\n        $props.step.header.title ? (openBlock(), createElementBlock(\"div\", {\n          key: 0,\n          innerHTML: $props.step.header.title\n        }, null, 8, _hoisted_3)) : createCommentVNode(\"\", true)\n      ])) : createCommentVNode(\"\", true)\n    ], true),\n    renderSlot(_ctx.$slots, \"content\", {}, () => [\n      createElementVNode(\"div\", _hoisted_4, [\n        $props.step.content ? (openBlock(), createElementBlock(\"div\", {\n          key: 0,\n          innerHTML: $props.step.content\n        }, null, 8, _hoisted_5)) : (openBlock(), createElementBlock(\"div\", _hoisted_6, \"props is a demo step! The id of props step is \" + toDisplayString($setup.hash) + \" and it targets \" + toDisplayString($props.step.target) + \".\", 1))\n      ])\n    ], true),\n    renderSlot(_ctx.$slots, \"actions\", {}, () => [\n      createElementVNode(\"div\", _hoisted_7, [\n        !$props.isLast && $setup.isButtonEnabled(\"buttonSkip\") ? (openBlock(), createElementBlock(\"button\", {\n          key: 0,\n          onClick: _cache[0] || (_cache[0] = withModifiers((...args) => $props.skip && $props.skip(...args), [\"prevent\"])),\n          class: \"v-step__button v-step__button-skip\"\n        }, toDisplayString($props.labels.buttonSkip), 1)) : createCommentVNode(\"\", true),\n        !$props.isFirst && $setup.isButtonEnabled(\"buttonPrevious\") ? (openBlock(), createElementBlock(\"button\", {\n          key: 1,\n          onClick: _cache[1] || (_cache[1] = withModifiers((...args) => $props.previousStep && $props.previousStep(...args), [\"prevent\"])),\n          class: \"v-step__button v-step__button-previous\"\n        }, toDisplayString($props.labels.buttonPrevious), 1)) : createCommentVNode(\"\", true),\n        !$props.isLast && $setup.isButtonEnabled(\"buttonNext\") ? (openBlock(), createElementBlock(\"button\", {\n          key: 2,\n          onClick: _cache[2] || (_cache[2] = withModifiers((...args) => $props.nextStep && $props.nextStep(...args), [\"prevent\"])),\n          class: \"v-step__button v-step__button-next\"\n        }, toDisplayString($props.labels.buttonNext), 1)) : createCommentVNode(\"\", true),\n        $props.isLast && $setup.isButtonEnabled(\"buttonStop\") ? (openBlock(), createElementBlock(\"button\", {\n          key: 3,\n          onClick: _cache[3] || (_cache[3] = withModifiers((...args) => $props.finish && $props.finish(...args), [\"prevent\"])),\n          class: \"v-step__button v-step__button-stop\"\n        }, toDisplayString($props.labels.buttonStop), 1)) : createCommentVNode(\"\", true)\n      ])\n    ], true),\n    createElementVNode(\"div\", {\n      class: normalizeClass([\"v-step__arrow\", { \"v-step__arrow--dark\": $props.step.header && $props.step.header.title }]),\n      \"data-popper-arrow\": \"\"\n    }, null, 2)\n  ], 10, _hoisted_1);\n}\nvar VStep = /* @__PURE__ */ _export_sfc(_sfc_main, [[\"render\", _sfc_render], [\"__scopeId\", \"data-v-da2d894c\"]]);\nconst install = (app) => {\n  app.config.globalProperties.$tours = {};\n  app.component(VTour.name, VTour);\n  app.component(VStep.name, VStep);\n};\nexport { install as default };\n",
      "start": 1700848819170,
      "end": 1700848819409,
      "sourcemaps": null
    },
    {
      "name": "nuxt:layer-aliasing",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "pre"
    },
    {
      "name": "nuxt:server-devonly:transform",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "pre"
    },
    {
      "name": "nuxt:client-fallback-auto-id",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "pre"
    },
    {
      "name": "vite:css",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "vite:esbuild",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "vite:json",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "vite:worker",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "vite:vue",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "vite:vue-jsx",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "nuxt:remove-plugin-metadata",
      "start": 1700848819409,
      "end": 1700848819409,
      "order": "normal"
    },
    {
      "name": "nuxt:chunk-error",
      "start": 1700848819409,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "nuxt:components:imports",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "replace",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "ssr-styles",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "vite:define",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "vite:css-post",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "vite:build-html",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "vite:worker-import-meta-url",
      "start": 1700848819410,
      "end": 1700848819410,
      "order": "normal"
    },
    {
      "name": "vite:asset-import-meta-url",
      "start": 1700848819411,
      "end": 1700848819411,
      "order": "normal"
    },
    {
      "name": "commonjs",
      "start": 1700848819411,
      "end": 1700848819433,
      "order": "normal"
    },
    {
      "name": "vite:dynamic-import-vars",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "normal"
    },
    {
      "name": "vite:import-glob",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "normal"
    },
    {
      "name": "nuxt:composable-keys",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "post"
    },
    {
      "name": "nuxt:imports-transform",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "post"
    },
    {
      "name": "unctx:transform",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "post"
    },
    {
      "name": "nuxt:pages-macros-transform",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "post"
    },
    {
      "name": "nuxt:runtime-paths-dep",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "post"
    },
    {
      "name": "nuxt:route-injection-plugin",
      "start": 1700848819433,
      "end": 1700848819433,
      "order": "post"
    },
    {
      "name": "nuxt:components-loader",
      "start": 1700848819433,
      "end": 1700848819434,
      "order": "post"
    },
    {
      "name": "nuxt:tree-shake-composables:transform",
      "start": 1700848819434,
      "end": 1700848819434,
      "order": "post"
    },
    {
      "name": "vite:build-import-analysis",
      "start": 1700848819434,
      "end": 1700848819434,
      "order": "normal"
    },
    {
      "name": "vite:reporter",
      "start": 1700848819434,
      "end": 1700848819434,
      "order": "normal"
    }
  ]
}
